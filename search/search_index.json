{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"<p>The Mobile.BuildTools is an easy to use NuGet package that adds new MSBuild targets to your build pipeline. In essence it teaches MSBuild some new tricks to help make your DevOps easier and help you follow better practices while developing your application. The bulk of support is around Xamarin.Android and Xamarin.iOS and it will work regardless of whether you are using the native tooling, Xamarin.Forms, or Uno to create your UI.</p> <p>The Mobile.BuildTools are a collection of MSBuild Tasks that help make MSBuild smarter in handling the build process for CI/CD with Mobile Applications. The library was born from a desire to share build processes from one app to the next without having to copy and paste a bunch of build scripts each of which could easily end up out of date. Because the Mobile.BuildTools simply provides MSBuild Tasks, this adds nothing to the size of your application and if being used on a project that will be packed and shared, you can set the PackageReference's PrivateAssets to all.</p> <p>NOTE</p> <p>The docs on this site are specific to the Mobile.BuildTools v2.0. For those still using v1.4 please refer to the Wiki on GitHub.</p>"},{"location":"#history","title":"History","text":"<p>The Mobile.BuildTools started out several years ago from powershell scripts I found myself writing from one project to the next to help me decouple app secrets and configuration values from the code base making these instead build time dependencies. Over the years this grew from the scripts I kept re-writing to scripts that I included out of the box with the Prism Quickstart templates. These features had nothing to do with Prism however, and I started looking at how these could be re-used for any Xamarin application. With that the Mobile.BuildTools was born. Over the years it has grown and had so many features added that I ultimately realized I better start writing a docs site as it has a solution for pretty much every problem I encounter when developing mobile apps.</p>"},{"location":"#support","title":"Support","text":"<p>This project is maintained by Dan Siegel. If this project has helped you please consider sponsoring Dan on GitHub. Your contributions help make great open source projects possible.</p> <p></p> <p>Note</p> <p>Enterprise Support is available through AvantiPoint. Please reach out if you require support for your apps with the Mobile.BuildTools, Prism or general assistance with your Xamarin, .NET Maui, or Uno Platform apps.</p>"},{"location":"#latest-nugets","title":"Latest NuGet's","text":"Package NuGet SponsorConnect Mobile.BuildTools Mobile.BuildTools.Configuration <p>Want to consume the CI packages? Sign up as a GitHub sponsor and you can access the Sponsor Connect private feed.</p>"},{"location":"#why-use-the-mobilebuildtools","title":"Why Use the Mobile.BuildTools","text":"<p>The Mobile.BuildTools is designed to help you with a variety of tasks that make mobile app development easier and help you to follow best practices keeping app secrets as well as environment configurations out of your source control. Additionally the Mobile.BuildTools has a variety of helpers that can help you manage your image resources, white label apps, or generally make it easier to build your app for side by side installation for different environments like Dev, Stage, and Production.</p>"},{"location":"#what-does-it-do","title":"What does it do?","text":"<ul> <li>Automatic app bundle copy to artifacts folder in the Solution directory<ul> <li>On iOS this copies your IPA + dSYM</li> <li>On Android this copies your APK / AAB</li> </ul> </li> <li>Automatically update the app version<ul> <li>Configurable for local, build host or both</li> <li>Configurable to use timestamp or BuildId if it exists + user defined Offset</li> </ul> </li> <li>Tokenize your Info.plist / AndroidManifest.xml (<code>$$SomeKey$$</code>)<ul> <li>Tokens replaced at build in obj to protect any against configuration values being checked in</li> </ul> </li> <li>Support for SCSS files to generate Xamarin.Forms CSS files</li> <li>Generate 'AppSettings' class at build that contains any configuration or application secrets<ul> <li>Supports all primitive data types + Uri, DateTime, DateTimeOffset, TimeStamp, &amp; Guid</li> <li>Any property can be made an array of values (useful for feature flags or OAuth scopes)</li> </ul> </li> <li>ConfigurationManager with app.config<ul> <li>Optimized for Mobile with familiar Static API and Interface based Singleton</li> <li>Offers Opt-In API for doing runtime transformations and bundling app.config's</li> <li>App.config transformations at build</li> <li>Optionally bundle all config's or config's with Non-Standard environment (i.e. not Debug, Release)</li> </ul> </li> <li>Simplified Image Handling (Android, iOS, macOS, tvOS)<ul> <li>Ability to store single high resolution images in one or more directories</li> <li>Ability to conditionally include images in directories based on the build target (i.e. iOS or Android)</li> <li>Ability to conditionally include images in directories based on the build configuration (i.e. Debug or !Debug)</li> <li>Ability to include images that may only be used as an overlay for another image.</li> <li>Ability to Draw Banner on images (i.e. Dev, Debug, Free, Pro)<ul> <li>User controlled Text</li> <li>User controlled Text color &amp; Font from System Font or local font file</li> <li>User control Banner color.. can include a single color for a solid look, or multiple colors for a gradient</li> </ul> </li> <li>Ability to generate additional outputs for a single input image</li> <li>Ability add padding around an image</li> <li>Ability to add a background color to a transparent image</li> <li>Supports PNG &amp; JPG file types</li> <li>Support for SVG and Gif (Planned)</li> </ul> </li> <li>Release Notes generation<ul> <li>Customizable output based on latest commit messages</li> <li>(Planned) Support for user templating and Flag based messages since last release/Git Tag... (i.e. <code>[Bug][iOS] Some bug got fixed</code>)</li> </ul> </li> </ul>"},{"location":"#additional-notes","title":"Additional Notes","text":"<p>Some additional notes... the Mobile.BuildTools will help with some advanced scenarios like:</p> <ul> <li>Generating app bundles that have different ID's for different environments</li> <li>White Labeling</li> <li>Use the Secrets to generate Feature Flags</li> <li>Generate Free or Lite versions of your app along with a Pro version</li> <li>Using the image api you could have a single input image and generate each of the following<ul> <li>All of the outputs defined for the AppIcon iconset on iOS</li> <li>A typical BundleResource 1x, 2x, 3x for using in your SplashScreen storyboard</li> <li>A typical Drawable for you a splash screen activity (ldpi, mdpi, hdpi, xhdpi, xxhdpi, xxxhdpi)</li> <li>The smaller icon file in the mipmap folders (ldpi, mdpi, hdpi, xhdpi, xxhdpi, xxxhdpi)</li> <li>The larger launcher_foreground file in the mipmap folders (ldpi, mdpi, hdpi, xhdpi, xxhdpi, xxxhdpi)</li> </ul> </li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>The Mobile.BuildTools relies a lot on JSON configurations because JSON is easy for most developers to work with.</p> FileName Schema Url appsettings.json n/a - JSON Dictionary buildtools.json https://mobilebuildtools.com/schemas/v2/buildtools.schema.json {imageName}.json https://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json"},{"location":"configuration/#appsettingsjson","title":"appsettings.json","text":"<p>Everyone has a different opinion of how they would like to set things up. While the Mobile.BuildTools is opinionated in certain ways, we also try to make efforts to meet developers where their needs are giving you some flexibility in configuration. Within a CI environment, the Mobile.BuildTools relies on Environment Variables to map values you need in your app. However this is a bit of a pain to deal with for local app development. The Mobile.BuildTools has long relied on a <code>secrets.json</code> file containing the dictionary values of the various variables you need for your build. With version 2.0 we have deprecated <code>secrets.json</code> in favor of <code>appsettings.json</code>. Additionally we hav added a few benefits to this allowing you to now pick and choose which file directory you would like the appsettings.json to live in. This can be any directory from the directory where your Solution file is located up to the Project directory. This can be particularly helpful when you may be using the Mobile.BuildTools to supply values across multiple projects or even where you may be replacing certain values in your AndroidManifest.xml or Info.plist.</p>"},{"location":"configuration/#buildtoolsjson","title":"BuildTools.json","text":"<p>One of the biggest changes in the Mobile.BuildTools 2.0 is the introduction of the <code>buildtools.json</code>. Because we provide an easy to use json configuration with a Json Schema you have the ability to get intellisense in Visual Studio, Visual Studio Code, as well as many other editors that support Json Schemas. This makes it much easier for you to configure the Mobile.BuildTools rather than relying on MSBuild properties which can confuse many developers. </p> <pre><code>{\n  \"$schema\": \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\"\n}\n</code></pre> <p>Note</p> <p>Some features may still utilize MSBuild parameters which can be defined in your CI Build to customize behavior during a CI build. An example of this would be an override to the Image search paths which can be particularly useful for White Labeling apps.</p>"},{"location":"configuration/#image-configuration-json","title":"Image Configuration Json","text":"<p>The Images API for the Mobile.BuildTools is incredibly powerful and dynamic. One of the ways that we support powerful image creation is by incorporating a configuration file for each image. By convention the configuration file should have the same file name (minus the file extension) of the image resource. You can then customize the output image resource name. This can be done globally or be specific on a specific platform like iOS or Android. Additionally you can configure a single input image to have multiple outputs. An example of this scenario could be that you have a resource that will be used for the App Icon. On Android you may output both the standard image and the \"Launcher\" image which may have additional padding to look good as a round icon.</p>"},{"location":"credits/","title":"Credits","text":"<p>While the Mobile.BuildTools does not add any external dependencies to your projects, we could not do what we do without being able to build on the hard work from other projects. Though the Mobile.BuildTools is licensed under the MIT License, some of our dependencies use alternate Open Source licenses.</p> Project License GitHub MSBuild MIT microsoft/msbuild Newtonsoft.Json MIT JamesNK/Newtonsoft.Json Microsoft.Web.Xdt* Apache aspnet/xdt Svg.Skia MIT wieslawsoltes/Svg.Skia SkiaSharp MIT mono/SkiaSharp <p>Note</p> <p>Microsoft.Web.Xdt is the only reference added to projects, if using the Mobile.BuildTools.Configuration package. There is never any bloat added by the core Mobile.BuildTools package to your applications. Despite being from the aspnet team this package does not bring in any additional references.</p>"},{"location":"faq/","title":"F.A.Q.","text":""},{"location":"faq/#should-every-value-in-my-appsettings-be-secret","title":"Should every value in my AppSettings be \"Secret\"?","text":"<p>The AppSettings Class is a great way to prevent security vulnerabilities created from checking into source control things like Client Id's, Consumer Secrets, or Connection Strings. But it really doesn't have to stop there. In fact the AppSettings class is a great way of setting the configuration environment for your application at build. Should your build point to the Dev, Stage, or Production API? This is also a great way of being very intentional about it.</p>"},{"location":"faq/#does-the-appsettings-class-have-to-be-in-the-helpers-namespace-or-named-secrets","title":"Does the AppSettings class have to be in the Helpers namespace or named Secrets?","text":"<p>In short no it does not. This has always been configurable though it is much easier with version 2.0 as you can just update the Configuration for the project. See the App Settings Configuration topic for more information on how to configure this for version 2.</p>"},{"location":"faq/#do-all-of-the-things-that-the-mobilebuildtools-is-capable-of-execute-every-time-i-run-a-build","title":"Do all of the things that the Mobile.BuildTools is capable of execute every time I run a build?","text":"<p>We try to be smart about what we will and will not do. There is an initialization task that will run on each build which evaluates your project to determine if certain things should or should not occur. For instance if there are no SCSS files in your project that Target will not fire, similarly if you have disabled a target explicitly it should be skipped during the build.</p>"},{"location":"faq/#i-installed-the-mobilebuildtools-why-cant-i-access-the-configurationmanager","title":"I installed the Mobile.BuildTools why can't I access the ConfigurationManager?","text":"<p>We explicitly separated the ConfigurationManager from the Mobile.BuildTools as we recognize that not everyone will want to use this feature. In order to get the build time transformations you will need to have the Mobile.BuildTools installed in your platform projects, however you will need the Mobile.BuildTools.Configuration package installed in any project where you want to use the ConfigurationManager.</p>"},{"location":"maui/","title":".NET Maui","text":"<p>.NET Maui is the evolution of Xamarin. There is a lot to be excited about with .NET Maui. While this is still early days with .NET Maui and I have not yet had time to evaluate the Mobile.BuildTools with .NET Maui, there is also no reason why the Mobile.BuildTools would not work with .NET Maui. Many of the features included with the Mobile.BuildTools such as the Secrets API, is completely cross platform and can be used with literally any C# project including AspNetCore, Unit Tests, etc.</p> <p>For Platform Specific functionality such as the Image or Manifest processing, these rely on the iOS/Android SDK's which are shared by traditional Xamarin applications and .NET Maui apps. As such these should continue to work. If you encounter any issue with the Mobile.BuildTools and a .NET Maui application please be sure to file and issue on GitHub.</p>"},{"location":"release-notes/","title":"Release Notes","text":"<p>Generating Release notes can be painful. The Mobile.BuildTools will help solve this problem in v2.X with the Release Notes Task. For this we will generate a ReleaseNotes.txt automatically for you. The configuration options are shown here with their default values.</p> <pre><code>{\n  \"$schema\": \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\",\n  \"releaseNotes\": {\n    \"maxDays\": 7,\n    \"maxCommit\": 10,\n    \"characterLimit\": 250,\n    \"filename\": \"ReleaseNotes.txt\",\n    \"createInRoot\": true,\n    \"disable\": false\n  }\n}\n</code></pre>"},{"location":"appendix/aps/","title":"Apple Push Notifications","text":"<p>When using Push Notifications on iOS you must be sure to set the <code>aps-environment</code> from <code>development</code> to <code>production</code> before submitting to the App Store. The Mobile.BuildTools will handle this for you easily at build.</p> <p>Critical Note</p> <p>While this was originally slated for v2.0, this will not be done until 2.1.</p>"},{"location":"appendix/aps/#from-the-build-definition","title":"From the Build Definition","text":"<p>You can accomplish this easily by updating your build definition to pass additional MSBuild arguments with the value <code>/p:APSProductionEnvironment=true</code> and the Mobile.BuildTools will automatically update the <code>aps-environment</code> for you.</p> <pre><code>- task: XamariniOS@2\n  inputs:\n    solutionFile: '**/*.sln'\n    configuration: 'Store'\n    packageApp: true\n    runNugetRestore: false\n    args: '/p:APSProductionEnvironment=true'\n</code></pre>"},{"location":"appendix/aps/#from-the-msbuild-properties","title":"From the MSBuild Properties","text":"<p>You can alternatively do this through any Directory.Build.props or in the csproj of your iOS project by adding the following:</p> <pre><code>&lt;PropertyGroup Condition=\" $(Configuration) == 'Store' \"&gt;\n  &lt;APSProductionEnvironment&gt;true&lt;/APSProductionEnvironment&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"appendix/json-schemas/","title":"JSON Schemas","text":"<p>The Mobile.BuildTools relies a lot on JSON configurations because JSON is easy for most developers to work with.</p> FileName Schema Url secrets.json n/a - JSON Dictionary DEPRECATED appsettings.json n/a - JSON Dictionary buildtools.json https://mobilebuildtools.com/schemas/v2/buildtools.schema.json {imageName}.json https://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json"},{"location":"appendix/msbuild-props/","title":"MSBuild Properties","text":"<p>The Mobile.BuildTools additionally provides a number of MSBuild Properties to further assist advanced developers in creating advanced build pipelines.</p> PropertyName Description IsWindows IsUnix Indicates that you are running on a Linux or macOS build agent PowerShellExe returns the default path for the exe IsAndroidProject Indicates the current Target Framework is MonoAndroid IsiOSProject Indicates the current Target Framework is Xamarin.iOS IsUWPProject Indicates the current Target Framework is UAP IsMacOSProject Indicates the current Target Framework is Xamarin.Mac IsTizenProject Indicates the current Target Framework is Tizen BuildToolsArtifactOutputPath Will default to the Solution Directory in the <code>App</code> folder. In Azure DevOps it will default to the Build.ArtifactStagingDirectory again in the App folder. IsAppCenter Indicates the current build host is an App Center build agent IsAzureDevOps Indicates the current build host is an Azure DevOps build agent. IsAppVeyor Indicates the current build host is an AppVeyor build agent. IsBitBucket Indicates the current build host is a BitBucket build agent. IsGitHubActions Indicates the current build host is an GitHub Actions build agent. IsJenkins Indicates the current build host is a Jenkins build agent. IsTeamCity Indicates the current build host is a Team City build agent. IsBuildHost If any of the above CI Platforms return true this will indicate true as well."},{"location":"appendix/upgrade/","title":"Upgrading from 1.X","text":"<p>The Mobile.BuildTools 1.X is extremely reliable for generating app secrets! But 2.0 is much better at it. There were a number of factors that went into determining what we should and should not be doing.</p>"},{"location":"appendix/upgrade/#secrets","title":"Secrets","text":"<p>There is a lot about the Secrets class generation that has been completely refactored. The result is that you have far more options when generating secrets than you did in 1.X. The big thing to consider is that you will need to add a configuration for the Project in the solution you want to add secrets for. Secrets have undergone a rename for a variety of reasons. Be sure to configure the <code>appSettings</code> section of the <code>buildtools.json</code>. For more information on how to configure this be sure to see the Configuration documentation.</p>"},{"location":"config/","title":"App Configuration for Mobile Projects","text":"<p>Mobile Apps unlike traditional Desktop and Web projects are limiting for developers because you must define configuration values at build and not on deployment. The Mobile.BuildTools is here to help you solve this problem and meet you where you are.</p> <p>Developers have different needs at different times. For v1.X, the Mobile.BuildTools took the very opinionated idea that configuration values and app secrets should be treaded as something that should be strongly typed. This has a few advantages that come from errors surfacing at build time rather than runtime.</p> <p>Sometimes though it may be more desireable to perform quick swaps from one environment to another where you are certain that you are running the same exact tested binary build as you have previously. For this reason starting with v2.0 you will have support for using an app.config to provide you the same sort of configurations support that you may be used to from Desktop development or from the web.config variant with ASP.NET development.</p>"},{"location":"config/#see-also","title":"See Also","text":"<ul> <li>Using app.config</li> <li>Using App Settings</li> </ul>"},{"location":"config/app.config/","title":"App.config","text":"<p>The Mobile.BuildTools now includes support for using an app.config. It's important to note that we do not use the System.Configuration.ConfigurationManager, and instead use a lightweight custom implementation that allows you to initialize custom configurations at runtime which may not follow the typical app.config naming or perform transformations at runtime though this is generally not a good practice.</p> <p>By default Mobile.BuildTools will look for any file in the root of the head project named app.config or app.*.config. All of those files will be bundled automatically into the native app. If your file has an environment config for the build configuration such as app.debug.config this will perform a transform during build on the bundled app.config.</p> <pre><code>{\n  \"$schema\": \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\",\n  \"appConfig\": {\n    \"strategy\": \"TransformOnly\"\n  }\n}\n</code></pre> <p>Note</p> <p>By default the Mobile.BuildTools will only bundle the transformed app.config into your project. You can optionally set the strategy to <code>BundleAll</code> or <code>BundleNonStandard</code> if you require runtime transformations.</p>"},{"location":"config/app.config/#app-config-strategy","title":"App Config Strategy","text":"Strategy Description TransformOnly This the default strategy which will perform the transformation and only bundle a single transformed app.config into your project. BundleAll When set as the app config strategy this will bundle any app.config that you may have such as <code>app.debug.config</code> or <code>app.release.config</code> BundleNonStandard When set as the app config strategy this will limit bundled app config's to any that are not for standard Xamarin build configurations which include Debug, Release, Store, &amp; AdHoc. <p>Note</p> <p>All file names are compared ignoring case.</p>"},{"location":"config/app.config/#supported-platforms","title":"Supported Platforms","text":"Platform Supported NetStandard Yes NetCoreApp 3.1 Xamarin.iOS Yes MonoAndroid 8.0+ UWP* 16299+ Xamarin.Mac* Yes Xamarin.TVOS* Yes Tizen* Yes <p>Note</p> <p>Platform's with an asterisk have not been tested explicitly.</p>"},{"location":"config/app.config/#faq","title":"F.A.Q.","text":"<p>Q. Can I use the ConfigurationManager without using the Mobile.BuildTools? A. Yes you absolutely can. The AppConfigSample project in the samples folder does exactly that!</p> <p>Q. How do I use the Environments? A. By default Environments are disabled. This means that we will only copy the transformed app.config into your project and the ConfigurationManager will only read the primary app.config.</p>"},{"location":"config/app.config/in-code/","title":"Using It In Code","text":"<p>Note that all values from the AppSettings are strings by default. Any conversions will need to be handled in your code.</p> <pre><code>var foo = ConfigurationManager.AppSettings[\"Foo\"];\n</code></pre>"},{"location":"config/app.config/in-code/#initialization","title":"Initialization","text":"<p>Before using the ConfigurationManager you must initialize it.</p> <p>ConfigurationManager accepts a <code>bool</code> to enable runtime environments, this must be set to <code>true</code> if you want to use configuration transforms.</p> <p>AppDelegate.cs</p> <pre><code>public override bool FinishedLaunching(UIApplication app, NSDictionary options)\n{\n    ConfigurationManager.Init(true);\n    global::Xamarin.Forms.Forms.Init();\n    LoadApplication(new App());\n\n    return base.FinishedLaunching(app, options);\n}\n</code></pre> <p>MainActivity.cs</p> <pre><code>protected override void OnCreate(Bundle bundle)\n{\n    TabLayoutResource = Resource.Layout.Tabbar;\n    ToolbarResource = Resource.Layout.Toolbar;\n\n    base.OnCreate(bundle);\n\n    ConfigurationManager.Init(true, this);\n\n    global::Xamarin.Forms.Forms.Init(this, bundle);\n    LoadApplication(new App());\n}\n</code></pre>"},{"location":"config/app.config/in-code/#transformations","title":"Transformations","text":"<p>While the Mobile.BuildTools will automatically perform transformations at Build, runtime transformations are also supported for those scenarios where you may need to change environments for whatever business reason.</p> <p>For this let's consider that we have <code>app.config</code> and <code>app.foo.config</code>. We can transform to the Foo environment as follows:</p> <pre><code>var foo = ConfigurationManager.AppSettings[\"foo\"]; // My Foo\nConfigurationManager.Transform(\"foo\"); // This is not case sensitive\nfoo = ConfigurationManager.AppSettings[\"foo\"]; // Transformed Value\n</code></pre> <p>To convert back you can simply call:</p> <pre><code>ConfigurationManager.Reset();\n</code></pre> <p>Note</p> <p>In order to Transform the values in the ConfigurationManager at Runtime the ConfigurationManager must be initialized with the <code>enableRuntimeEnvironments</code> parameter set to true. <code>ConfigurationManager.Init(true)</code></p> <p>Note</p> <p>Calling Transform for an Environment that does not exist will not throw an error, it will however call Reset to restore the ConfigurationManager to it's original state.</p>"},{"location":"config/app.config/in-code/#testability","title":"Testability","text":"<p>The ConfigurationManager is Interface based and utilizes a Singleton. The singleton remains constant as long as ConfigurationManager.Init() is not called. You can Reset or Transform as often as you need. As a best practice it is recommended that you register the ConfigurationManager.Current instance with a Dependency Injection container and inject the IConfigurationManager into your code. This will allow you to mock the ConfigurationManager and better test your code.</p>"},{"location":"config/app.config/transformations/","title":"Transformations","text":"<p>A basic app config may look like:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;\n&lt;configuration&gt;\n  &lt;appSettings&gt;\n    &lt;add key=\"foo\" value=\"my foo\" /&gt;\n    &lt;add key=\"bar\" value=\"my bar\" /&gt;\n  &lt;/appSettings&gt;\n  &lt;connectionStrings&gt;\n    &lt;add name=\"test\" providerName=\"my provider\" connectionString=\"my connection string\"/&gt;\n  &lt;/connectionStrings&gt;\n&lt;/configuration&gt;\n</code></pre> <p>A Transformation config may look like:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;\n&lt;configuration xmlns:xdt=\"http://schemas.microsoft.com/XML-Document-Transform\"&gt;\n  &lt;appSettings&gt;\n    &lt;add key=\"foo\" value=\"transformed\" xdt:Transform=\"Replace\" xdt:Locator=\"Match(key)\"/&gt;\n    &lt;add key=\"Environment\" value=\"Dev\" xdt:Transform=\"Insert \"/&gt;\n  &lt;/appSettings&gt;\n&lt;/configuration&gt;\n</code></pre> <p>After running the transform from either the automatic build task, at runtime or with the .NET CLI Tool the resulting app.config will look like:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;\n&lt;configuration&gt;\n  &lt;appSettings&gt;\n    &lt;add key=\"foo\" value=\"transformed\" /&gt;\n    &lt;add key=\"bar\" value=\"my bar\" /&gt;\n    &lt;add key=\"Environment\" value=\"Dev\" /&gt;\n  &lt;/appSettings&gt;\n  &lt;connectionStrings&gt;\n    &lt;add name=\"test\" providerName=\"my provider\" connectionString=\"my connection string\"/&gt;\n  &lt;/connectionStrings&gt;\n&lt;/configuration&gt;\n</code></pre>"},{"location":"config/app.config/transformations/#xdt-transformations","title":"XDT Transformations","text":"<p>While the XDT namespace allows you to radically change your app.config. In most cases however you will only need to focus on the xdt:Transform attribute.</p> <ul> <li>Insert</li> <li>InsertBefore(XPath expression)</li> <li>InsertAfter(XPath expression)</li> <li>Remove</li> <li>Remove All</li> </ul> <p>To find out more about the available transformations, see the microsoft documentation.</p>"},{"location":"config/app.config/transformations/#replace","title":"Replace","text":"<p>This transformation requires the <code>xdt:Locator</code> attribute to function correctly. In most cases this will be a simple match on the key attribute:</p> <pre><code>&lt;add key=\"foo\" value=\"transformed\" xdt:Transform=\"Replace\" xdt:Locator=\"Match(key)\"/&gt;\n</code></pre> <p>See the documentation for all the ways in which the <code>xdt:Locator</code> attribute can be used.</p>"},{"location":"config/appsettings/","title":"Intro","text":"<p>Application Settings is a completely rewritten API from the legacy Secrets API. This is the evolution of the Secrets API and has an updated name to reflect the real intent as there are many time you are not actually protecting your codebase from actual application secrets as much as simply keeping configuration something that gets injected at build rather than being hard coded.</p> <p>Note</p> <p>If you were using a 2.0 preview, the BuildTools will attempt to migrate your configuration over to using the Application Settings</p>"},{"location":"config/appsettings/#what-are-appsettings","title":"What are AppSettings?","text":"<p>We all have settings that help make our app run whether in development, staging, or production. Some examples might be Client ID's, Backend Uri's, OAuth Scopes we need. When you have any of these sorts of things you can have the Mobile.BuildTools automatically generate one or more classes in your project.</p>"},{"location":"config/appsettings/#using-the-appsettingsjson","title":"Using the appsettings.json","text":"<p>The Mobile.BuildTools is smart, we look for the appsettings.json in the project and recurse up to the solution directory. This allows you to provide a single file for your entire solution while providing values that can be used through the solution.</p> <pre><code>{\n  \"AppCenterAppId\": \"{your app id}\",\n  \"BackendUri\": \"https://someapp.azurewebsites.net\"\n}\n</code></pre> <p>In addition to the core appsettings.json you can additionally provide an <code>appsettings.Debug.json</code> to override values for Debug and similarly with any other Build configuration that you may have following the format <code>appsettings.{Configuration}.json</code>.</p> <p>Note</p> <p>If upgrading to 2.0 and you are using a secrets.json, the secrets.json will continue to work with a build warning. You should convert the file over to <code>appsettings.json</code> as support for secrets.json will be deprecated in a future release.</p>"},{"location":"config/appsettings/#variable-priority","title":"Variable priority","text":"<p>The Mobile.BuildTools attempts to locate the values for your generated class through several sources. In the event that a variable key is duplicated, the Mobile.BuildTools has a precedence that the last one in wins. Variables are loaded from the following sources</p> <ol> <li>buildtools.json Environment Defaults</li> <li>buildtools.json Environment Configuration (i.e. Debug, Release)</li> <li>System Environment</li> <li>Recursively load legacy <code>secrets.json</code> from the Project directory to the Solution directory</li> <li>Recursively load <code>appsettings.json</code> from the Project directory to the Solution directory</li> </ol> <p>Note</p> <p>This variable gathering is additionally used for replacing Manifest tokens</p>"},{"location":"config/appsettings/configuration/","title":"Configuration","text":"<p>Configuration for App Settings is a little different than for Secrets in Mobile.BuildTools 1.x. While we do provide legacy support for getting values from the secrets.json this has been almost entirely rewritten to provide much more advanced scenarios as well as to solve some issues faced in CI.</p>"},{"location":"config/appsettings/configuration/#ci-platform-issues","title":"CI Platform Issues","text":"<p>A common problem with some build platforms such as Azure DevOps Windows Agents is that they cast all variables with ToUpper. This means that if you added <code>MyVariable</code>, what the Mobile.BuildTools would actually find was <code>MYVARIABLE</code>. With 1.x we had no way to convert this back to <code>MyVariable</code> for the source generation. This naturally caused a lot of problems. To solve this issue the Mobile.BuildTools now provides a configuration file that describes the projects and classes that it should generate.</p>"},{"location":"config/appsettings/configuration/#configuring-the-buildtoolsjson","title":"Configuring the buildtools.json","text":"<p>The Mobile.BuildTools 2.0 configuration gives us a lot of flexibility as we can define 1 or MORE classes that should be generated automatically at build. Additionally since we can describe the class in json, we can specify exactly the data type should be rather than relying on the Mobile.BuildTools to make an educated guess.</p> <pre><code>{\n  \"$schema\": \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\",\n  \"appSettings\": {\n    \"AwesomeApp\": [\n      {\n        // Your configuration here\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"config/appsettings/configuration/#class-configuration","title":"Class Configuration","text":"<p>Within the Project we can now provide any configuration values we need to either override or explicitly provide that will control how the class will be generated.</p> <pre><code>{\n  \"$schema\": \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\",\n  \"projectSecrets\": {\n    \"AwesomeApp\": [\n      {\n        \"accessibility\": \"Internal\",\n        \"className\": \"AppSettings\",\n        \"delimiter\": \";\",\n        \"namespace\": \"Helpers\",\n        \"rootNamespace\": null,\n        \"prefix\": \"BuildTools_\",\n        \"properties\": [\n          // Property Definitions\n        ]\n      }\n    ]\n  }\n}\n</code></pre> <p>Note</p> <p>If we do not provide any of the values shown above they will automatically default as shown. Only the <code>properties</code> are required.</p>"},{"location":"config/appsettings/configuration/#property-configuration","title":"Property Configuration","text":"<p>The Mobile.BuildTools 2.0 added support for every primitive datatype, along with DateTime, DateTimeOffset, Uri, &amp; Guid. Additionally you now have the ability to easily specify that a value should be an array. Note that this only generates arrays, you cannot specify other types such as <code>List</code> or <code>Collection</code>.</p> <pre><code>{\n  \"$schema\": \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\",\n  \"projectSecrets\": {\n    \"AwesomeApp\": [\n      {\n        \"properties\": [\n          {\n            \"name\": \"MyProperty\",\n            \"type\": \"String\"\n          },\n          {\n            \"name\": \"MyProperty2\",\n            \"type\": \"Int\"\n          },\n          {\n            \"name\": \"MyProperty3\",\n            \"type\": \"String\",\n            \"array\": true\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"config/appsettings/configuration/#providing-a-default-value","title":"Providing a Default Value","text":"<p>There are a lot of values which either may not be sensitive or a default value would be safe to have in source control. We'll look at two scenarios here.</p>"},{"location":"config/appsettings/configuration/#default-value-for-app-center-app-id","title":"Default value for App Center App Id","text":"<p>It's pretty common for people using the Mobile.BuildTools to inject values such as the App Center App Id to be able to initialize the App Center SDK. It's also pretty common that you may not want to provide a value for local development. The Mobile.BuildTools makes this easy by understanding the reserved values of <code>null</code> and <code>default</code>. It doesn't matter which one you use, the Mobile.BuildTools will actually generate the code using the <code>default</code> keyword as this is safe across all data types, nullable, and non-nullable alike.</p> <pre><code>{\n  \"$schema\": \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\",\n  \"appSettings\": {\n    \"AwesomeApp\": [\n      {\n        \"properties\": [\n          {\n            \"name\": \"AppCenterAppId\",\n            \"type\": \"String\",\n            \"defaultValue\": \"null\"\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"config/appsettings/configuration/#user-specified-default-value","title":"User specified Default value","text":"<p>Other times we may have non-sensitive values that we need to configure defaults for. In the following scenario we may be setting up UDP logging with a Syslog Server. We know that the default port for UDP Syslog Servers is port 514. This value can simply be placed as </p> <pre><code>{\n  \"$schema\": \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\",\n  \"appSettings\": {\n    \"AwesomeApp\": [\n      {\n        \"properties\": [\n          {\n            \"name\": \"SyslogServerPort\",\n            \"type\": \"Int\",\n            \"defaultValue\": \"514\"\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"config/appsettings/configuration/#handling-duplicate-property-names","title":"Handling Duplicate Property Names","text":"<p>There may be times in which you have more than one project in your solution, or perhaps just more than one generated settings class that require duplicate property names. An example of this could be an API Settings class. </p> <pre><code>{\n  \"$schema\": \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\",\n  \"appSettings\": {\n    \"AwesomeApp\": [\n      {\n        \"className\": \"FooApiSettings\",\n        \"properties\": [\n          {\n            \"name\": \"BaseUri\",\n            \"type\": \"Uri\"\n          }\n        ]\n      },\n      {\n        \"className\": \"BarApiSettings\",\n        \"properties\": [\n          {\n            \"name\": \"BaseUri\",\n            \"type\": \"Uri\"\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre> <p>In this sample we have 2 generated classes with the <code>BaseUri</code> property, this creates a few problems for us because we need to distinguish which Uri belongs to which class and ultimately our JSON would be invalid because it has a duplicated key</p> <pre><code>{\n  \"BaseUri\": \"https://api.foo.com\",\n  \"BaseUri\": \"https://api.bar.com\"\n}\n</code></pre> <p>To solve this problem we can use the Prefix property on our generated class settings. In this way we can specify a unique variable prefix that will be used to identify which Base Uri property belongs to which generated class</p> <pre><code>{\n  \"$schema\": \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\",\n  \"appSettings\": {\n    \"AwesomeApp\": [\n      {\n        \"className\": \"FooApiSettings\",\n        \"prefix\": \"FooApi_\",\n        \"properties\": [\n          {\n            \"name\": \"BaseUri\",\n            \"type\": \"Uri\"\n          }\n        ]\n      },\n      {\n        \"className\": \"BarApiSettings\",\n        \"prefix\": \"BarApi_\",\n        \"properties\": [\n          {\n            \"name\": \"BaseUri\",\n            \"type\": \"Uri\"\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre> <p>With the Prefix added we can now update our appsettings.json to be:</p> <pre><code>{\n  \"FooApi_BaseUri\": \"https://api.foo.com\",\n  \"BarApi_BaseUri\": \"https://api.bar.com\"\n}\n</code></pre> <p>[!NOTE] If your prefix does not end with an underscore one will automatically be inserted. In the above example if we did not explicitly have the underscore, the Mobile.BuildTools would still be expecting the same values in our <code>appsettings.json</code> or as an Environment variable.</p>"},{"location":"config/appsettings/configuration/#setting-variables-from-the-environment","title":"Setting Variables from the environment","text":"<p>The Mobile.BuildTools allows us to \"Fake\" environment variables. There may be times such as the previous sample with our previous example where the values aren't particularly sensitive but simply something that may change based on our Build... </p> <pre><code>{\n  \"$schema\": \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\",\n  \"environment\": {\n    \"defaults\": {\n      \"FooApi_BaseUri\": \"https://dev.api.foo.com\",\n      \"BarApi_BaseUri\": \"https://dev.api.bar.com\"\n    },\n  }\n}\n</code></pre> <p>It's also possible that we may want to further customize this without the need to update a CI Build environment for variables that aren't particularly sensitive. In this case we can provide Build Configuration specific settings:</p> <pre><code>{\n  \"$schema\": \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\",\n  \"environment\": {\n    \"configuration\": {\n      \"Debug\": {\n        \"FooApi_BaseUri\": \"https://dev.api.foo.com\",\n        \"BarApi_BaseUri\": \"https://dev.api.bar.com\"\n      },\n      \"QA\": {\n        \"FooApi_BaseUri\": \"https://qa.api.foo.com\",\n        \"BarApi_BaseUri\": \"https://qa.api.bar.com\"\n      },\n      \"Release\": {\n        \"FooApi_BaseUri\": \"https://api.foo.com\",\n        \"BarApi_BaseUri\": \"https://api.bar.com\"\n      }\n    },\n  }\n}\n</code></pre>"},{"location":"config/appsettings/configuration/#fuzzy-matching","title":"Fuzzy Matching","text":"<p>From time to time you may want to make use of Fuzzy Matching. Fuzzy Matching allows you to provide configurations that aren't tied to a specific Build Configuration name. For example we might have an <code>appsettings.QA.json</code> with a <code>DebugQA</code> build configuration. We might also have a <code>ReleaseQA</code> build configuration. In the case we build with either of these build configurations we might want it to pick up the QA build configuration. We can pick these configurations up by enabling Fuzzy Matching in our environment.</p> <pre><code>{\n  \"$schema\": \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\",\n  \"environment\": {\n    \"enableFuzzyMatching\": true\n  }\n}\n</code></pre>"},{"location":"config/appsettings/faq/","title":"F.A.Q.","text":"<p>Q. I'm using a shared project with my Uno app, each app obviously has a different namespace. How can I get the generated class to use a specific root namespace? A. When configuring the AppSettings there are 2 namespace fields. You will need to set the <code>rootNamespace</code>. This will override the RootNamespace of the compiling project.</p> <p>Q. How can change the default namespace of the generated class to be in the root namespace of my project? A. Simply provide a value of <code>.</code> for the namespace property</p> <p>Q. What is the <code>delimiter</code> used for? A. Json objects are effectively a dictionary which cannot have repeated keys, similarly Environment Variables operate the same way. As a result things which are ultimately lists such as the PATH Environment property utilize a delimiter such as <code>;</code> to separate the items in the list. By default the Mobile.BuildTools will use the semi-colon, though you can use any character or string you want. Any variables you've defined as arrays will use that delimiter to split the string into an array of whatever your datatype is.</p> <p>Q. Is there a way to get the generated class to use a List instead of an Array? A. No, this is a limitation of the API. If this is an issue for you please open an issue and explain your use case.</p>"},{"location":"continuous-integration/platforms/","title":"Build Platforms","text":"<p>Because the Mobile.BuildTools is a collection of MSBuild Targets, it works absolutely everywhere that MSBuild is available and building your project. It doesn't matter if you use Cake, or CLI scripts, or which CI platform you use. In general all of the common CI Platforms that Xamarin Developers might use are covered this includes:</p> <ul> <li>App Center</li> <li>Azure DevOps</li> <li>Appveyor</li> <li>Jenkins</li> </ul>"},{"location":"continuous-integration/setup/","title":"Continuous Integration Setup","text":"<p>Obviously if we checked in a json file with our secrets it would negate the entire point of trying to secure our code base. The Build Tools include a Build Host Secrets task that executes prior to the Secrets Generation. This task will execute when the secrets json file does not exist in an attempt to generate the missing json file. This is designed to handle secrets across multiple projects. By default we assume you have a single shared project such as a .NET Standard library, and one or more platform projects like iOS, Android, UWP, macOS, &amp; Tizen. To override the secrets prefix for any project you simply need to provide a value for <code>BuildHostSecretPrefix</code></p> Platform Secrets Prefix Android DroidSecret_ iOS iOSSecret_ UWP UWPSecret_ macOS MacSecret_ Tizen TizenSecret_ Default BuildTools_"},{"location":"google/","title":"Google Firebase","text":"<p>Google Firebase is an incredibly popular solution for app analytics and cross platform push notifications. Unfortunately we see a lot of developers following poor programming practices including the <code>google-services.json</code> and <code>GoogleService-Info.plist</code> in source control. The Mobile.BuildTools is all about empowering you to follow best practices while developing your mobile apps. </p> <p>To start be sure to add these files to your <code>.gitignore</code> that way the file isn't accidentally checked into source control while you use it for local development. The Mobile.BuildTools is able to bring these resources in at build time using your favorite CI Build service. To get started you'll want to come up with a variable name and set this in your <code>buildtools.json</code> like the following:</p> <pre><code>{\n  \"google\": {\n    \"servicesJson\": \"GoogleServicesJson\",\n    \"infoPlist\": \"GoogleServicesInfoPlist\"\n  }\n}\n</code></pre> <p>If the variable exists locally or on your CI Server, the Mobile.BuildTools will automatically look it up and determine if it is a file path. If it is it will add the appropriate include for iOS/Android. Otherwise it will take the contents of the variable and add the file to the Intermediate Output Directory (the obj folder) during the build, and it will again add the appropriate platform include.</p> <p>Note</p> <p>Due to some build agents, such as all Windows agents on Azure DevOps, performing a ToUpper on all environment variable names, the Mobile.BuildTools will do a Case insensitive lookup to match the variable name.</p>"},{"location":"images/","title":"Image Asset Generation","text":"<p>It takes about 5 minutes as a Mobile developer until you realize that Mobile apps have a lot of image assets. If you're a Cross Platform developer you realize that with your doubled reach comes a doubling of the amount of image assets you need to track. One of the premiere features of the Mobile.BuildTools in version 2 is the ability to handle custom asset generation. We do this by only tracking or letting you worry about the Full Resolution image assets that you want as part of your app.</p> <p>Important</p> <p>It is extremely important to note that the Image Processing features listed here are largely WIP guidance on how these features are intended to work. As Image Processing is still very much WIP, not everything listed here may currently be functioning as expected.</p>"},{"location":"images/#adding-image-search-directories","title":"Adding Image Search Directories","text":"<p>The Mobile.BuildTools allows you to bring in images within one or more directories in 3 different ways:</p> <ul> <li>Directories that should be searched for all builds</li> </ul> <pre><code>{\n  \"images\": {\n    \"directories\": [\n      \"Images\"\n    ]\n  }\n}\n</code></pre> <ul> <li>Directories that should conditionally be searched. See Conditional Directories for more information.</li> </ul> <pre><code>{\n  \"images\": {\n    \"conditionalDirectories\": {\n      \"someCondition\": [ \"AnotherDirectory\" ]\n    }\n  }\n}\n</code></pre> <ul> <li>MSBuild Configured Directories typically used in CI which can optionally override your json configuration. See the Build Customization topic for more information.</li> </ul> <p>Warning</p> <p>The Mobile.BuildTools will only evaluate images in the top level of the specified directories. Images in subdirectories will be ignored unless otherwise specified as a search directory or conditional directory.</p>"},{"location":"images/#conditional-directories","title":"Conditional Directories","text":"<p>Conditional Directories supercharges your ability deliver customized images for your apps. The Conditional Directories help us to get a better handle on what image assets we want to include either for a specified Target Platform or Build Configuration.</p>"},{"location":"images/#supported-conditions","title":"Supported Conditions","text":"<p>Platform Conditions</p> <p>A powerful feature of the Mobile.BuildTools is the ability to customize by Build Platform. This allows to to use the office Target Framework Moniker (TFM) or the more friendly platform name like the following.</p> <ul> <li>Xamarin.iOS</li> <li>iOS</li> <li>MonoAndroid</li> <li>Android</li> </ul> <p>Build Configurations</p> <ul> <li>Any Build Configuration you have!</li> <li>Optionally negate a Condition like <code>!Debug</code></li> </ul> <pre><code>{\n  \"images\": {\n    \"directories\": [\n      \"Images\",\n      \"Images\\\\Shared\"\n    ],\n    \"conditionalDirectories\": {\n      \"MonoAndroid\": [ \"Images\\\\Android\" ],\n      \"Xamarin.iOS\": [ \"Images\\\\iOS\" ],\n      \"Debug\": [ \"Images\\\\Debug\" ],\n      \"!Store\": [ \"Images\\\\NotProduction\" ],\n      \"Store\": [ \"Images\\\\Production\" ]\n    }\n  }\n}\n</code></pre>"},{"location":"images/#sample-outputs","title":"Sample Outputs","text":"<p>Using Conditional Directories along with the ability to watermark images (see Configuring Images topic) you can easily transform images.</p> <p>For this let's say that we have two watermark images that we want to use on one or more of the images that will be used in our app.</p> <p>Let's next say that we have two images we want to test this on like the following:</p> <p>Important</p> <p>You may have noticed from looking at these images that all of the images are different resolutions. The Mobile.BuildTools is smart enough to understand that we want to scale your watermark and your input image to share the same canvas size. We will then generate the appropriate output size based on what your needs are.</p>"},{"location":"images/#limitations","title":"Limitations","text":"<p>Keep in mind that we do require that each image have a sibling json configuration file. This means that if your image is at the path: <code>Images\\foo.png</code>, then we would expect a configuration at <code>Images\\foo.json</code>, even if that file is an empty JSON file.</p> <p>When using Conditional Directories it is very much possible that you would have more than one json configuration file for a single image. The Mobile.BuildTools will ignore the sibling configuration any time a second json configuration file is found in another directory.</p> <p>Warning</p> <p>While the Mobile.BuildTools can handle locating 2 json configurations during a build where one of them is a sibling of the image, the Mobile.BuildTools cannot handle scenarios where you it locates more than one json configuration that is not a sibling of the image as we would not know which one is the proper one to use.</p>"},{"location":"images/#supported-platforms","title":"Supported Platforms","text":"<p>Not all platforms are supported. For more information see the grid below:</p> Platform Status Android Supported iOS Supported macOS Supported * tvOS Supported * Tizen Not Supported - See issue #101 UWP Not Supported - See issue #100 Blazor Not Planned Web Assembly Not Planned <p>* Platform is theoretically supported as there should be no difference from iOS, however this has not been directly tested.</p>"},{"location":"images/build-customization/","title":"Build Customization","text":"<p>The image processing feature of the Mobile.BuildTools has always been built with the intention of making white labeling apps or customizing resources like app icons based on build environment easier. Because of this, in addition to configuring this feature with the buildtools.json, we also support overriding your default configuration at build using more conventional MSBuild properties.</p>"},{"location":"images/build-customization/#customizing-the-search-paths","title":"Customizing the Search Paths","text":"<p>In order to customize the search paths at build you should set the Property <code>BuildToolsImageSearchPath</code>. This property can contain multiple paths as long as the paths can be split with a semi-colon <code>;</code>.</p> <p>Setting the property could be as simple as the following:</p> <pre><code>&lt;PropertyGroup&gt;\n  &lt;BuildToolsImageSearchPath&gt;$(SolutionDir)\\Images\\MoreImages;$(SolutionDir)\\Images\\AwesomeImages&lt;/BuildToolsImageSearchPath&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"images/build-customization/#overriding-the-json-configuration","title":"Overriding the Json Configuration","text":"<p>The Image Processing feature of the Mobile.BuildTools allows you to completely override your JSON configuration at build by specifying an additional property <code>BuildToolsIgnoreDefaultSearchPath</code>. By setting this property to true in the presence of any build defined search paths, we will ignore all paths including the conditional paths specified in the buildtools.json.</p>"},{"location":"images/build-customization/#putting-this-together","title":"Putting this together","text":"<p>To understand how we might use this in a DevOps environment we'll look at some YAML to see how this would look with Azure Pipelines:</p> <pre><code>- task: XamariniOS@2\n  displayName: 'Build Xamarin.iOS solution'\n  inputs:\n    solutionFile: 'src/AwesomeApp.iOS/AwesomeApp.iOS.csproj'\n    configuration: ${{ parameters.buildConfiguration }}\n    packageApp: true\n    runNuGetRestore: true\n    args: '/p:BuildToolsImageSearchPath=''$(ClientImages)'' /p:BuildToolsIgnoreDefaultSearchPath=true'\n  env:\n    Secret_SampleString: 'Sample String'\n    Secret_SampleInt: '1'\n    Secret_SampleDouble: '2.1'\n    Secret_SampleBool: 'true'\n</code></pre>"},{"location":"images/built-in-templates/","title":"Built In Templates","text":"<p>When using the built in drawing API in the Mobile.BuildTools, we will draw one a custom banner and text in one of 6 layouts.</p> Top Left Top Top Right Bottom Left Bottom Bottom Right <p>What can you edit?</p> <ul> <li>Use your specified text</li> <li>Use any system installed font</li> <li>Use a custom font from a specified font file</li> <li>Specify the Text Color</li> <li>Specify One or More Colors for the Banner to get your preferred style (solid or gradient)</li> </ul>"},{"location":"images/configuring-images/","title":"Configuring Images","text":"<p>The first time the Mobile.BuildTools encounters an image it will automatically generate a default image configuration file along side of the image. This file is what allows you to customize and further refine the image that you want. A configuration file may reside a conditional search directory. The Mobile.BuildTools will opt to use a configuration that is not in the same file directory as the image resource any time that a duplication is found.</p> <p>Warning</p> <p>Keep in mind that we only ever support a scenario where you have a single configuration in a directory other than the original image. In the event that two or more configurations are found for the same image in directories other than the directory where the image is located the Mobile.BuildTools will throw an exception causing a Build Error.</p> <p>Note</p> <p>If you have an image name that contains white space such as <code>foo bar.png</code>, the Mobile.BuildTools will sanitize the file name replace any contiguous white space characters with a single <code>-</code>. This normalization is required by Android and will mean that you will need to reference the image as <code>foo-bar.png</code>.</p>"},{"location":"images/configuring-images/#configuring-images","title":"Configuring Images","text":"<p>The Schema for configuring images is rather simple by design. We allow you to specify a watermark file name, a name, a scale and an optional ignore. To start let's consider that we have an image named <code>Mobile-BuildTools.png</code>. We know that we cannot get away with this file name on all platforms so we want to rename the generated image.</p> <pre><code>{\n  \"$schema\": \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\",\n  \"name\": \"mobile_buildtools\"\n}\n</code></pre> <p>The above sample would allow us to have a resource named <code>mobile_buildtools</code> when we refer to this from our Xamarin code.</p>"},{"location":"images/configuring-images/#platform-specific-configurations","title":"Platform Specific Configurations","text":"<p>There is a common schema for image configuration which includes the following properties:</p> <pre><code>{\n  \"$schema\": \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\",\n  \"name\": \"someName\",\n  \"scale\": 0.875,\n  \"backgroundColor\": \"#ffffff\",\n  \"ignore\": false,\n}\n</code></pre> <p>This schema is available generally for each image and can be used to further tweak or customize for the platform. As an example let's consider that we want the <code>Mobile-BuildTools.png</code> to be used as the app icon. We will want to use the App Icon Set on iOS named <code>AppIcon</code> and we'll want to use the image name <code>icon</code> on Android. To accomplish this our configuration would look like:</p> <pre><code>{\n  \"$schema\": \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\",\n  \"android\": {\n    \"name\": \"icon\"\n  },\n  \"apple\": {\n    \"name\": \"AppIcon\"\n  }\n}\n</code></pre> <p>Let's now consider a few facts about our icon that would be quite common, particularly when sharing the same resource between iOS and Android for the App Icon.</p> <ul> <li>We want the Android resource to be in the mipmap folder rather the drawable folders</li> <li>Our full size image is much larger than the full size icon should be for Android</li> <li>Our image has a transparent background which will need to be adjusted on iOS</li> </ul> <p>Given these additional criteria we would want to update our configuration as follows:</p> <pre><code>{\n  \"$schema\": \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\",\n  \"android\": {\n    \"name\": \"icon\",\n    \"resourceType\": \"Mipmap\",\n    \"scale\": 0.375\n  },\n  \"apple\": {\n    \"name\": \"AppIcon\",\n    \"backgroundColor\": \"#fc7e00\"\n  }\n}\n</code></pre> <p>Note</p> <p>Android specific configuration defines an additional property for the Resource Type. By default this is set to Drawable. You can however change this in your image configuration for <code>mipmap</code> resources.</p>"},{"location":"images/configuring-images/#watermarking-images","title":"Watermarking Images","text":"<p>One of the great things that the Mobile.BuildTools supports is watermarking images at build. This is a very powerful feature as shown below. To configure images for Watermarking there are a few simple steps that you will need to take.</p> <p>Let's first make a couple of assumptions.</p> <ul> <li>You have your base resources in the path <code>Images</code></li> <li>This includes an image asset called <code>icon.png</code></li> <li>You have a subfolder called <code>Images\\Debug</code></li> <li>Inside of this directory you have a watermark file called <code>beta-version.png</code></li> </ul> <p>In order to set this up our <code>buildtools.json</code> might look like this:</p> <pre><code>{\n  \"images\": {\n    \"directories\" : [ \"Images\" ],\n    \"conditionalDirectories\": {\n      \"Debug\": [ \"Images\\\\Debug\" ]\n    }\n  }\n}\n</code></pre> icon.png beta-version.png output: icon.png <p>When the Mobile.BuildTools runs and the Image collector locates an image, it will automatically generate a default JSON configuration file. The configuration file must have the same name as the image without the file extension. As a result after the first run our output image will look exactly the same as our input image only resized, and we would also have an asset added for the <code>beta-version.png</code> although this was not what we had wanted. The file system will also now contain the new files <code>Images\\icon.json</code> &amp; <code>Images\\Debug\\beta-version.json</code>.</p> <p>You will not need to do anything to the <code>Images\\icon.json</code> file, however you will want to copy this to <code>Images\\Debug</code> directory. Next you'll want to open a text editor such as Visual Studio Code which will automatically pick up the schema referenced in the generated file and give you intellisense as you work on the file. We'll update the following two files as follows:</p> <p>Images\\Debug\\beta-version.json</p> <pre><code>{\n  \"$schema\": \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\",\n  \"ignore\": true\n}\n</code></pre> <p>Images\\Debug\\icon.json</p> <pre><code>{\n  \"$schema\": \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\",\n  \"watermark\": {\n    \"sourceFile\": \"beta-version\"\n  }\n}\n</code></pre> <p>Warning</p> <p>When using Conditional Directories to modify images with watermarks be sure that there is never more than one conditional configuration included. Doing so will result in a build error as the Mobile.BuildTools has no way of know which conditional configuration to use.</p> <p>With our updated configurations we can now rebuild and the Mobile.BuildTools will generally ignore the <code>beta-version.png</code> as an asset of it's own while it will apply the beta-version.png as an overlay to our icon during our debug builds.</p>"},{"location":"images/configuring-images/#drawn-watermarks","title":"Drawn Watermarks","text":"<p>Just like mentioned above we can provide a configuration file for our image in a conditional directory to use the full watermarking power without having to have any specific image resource for our overlay. The Mobile.BuildTools provides a built in powerful drawing API with 6 different layout options and complete customization of the text, font and colors used.</p> <pre><code>{\n  \"watermark\": {\n    \"colors\": [ \"Purple\", \"#008888\" ],\n    \"text\": \"Dev\",\n    \"fontFamily\": \"Times New Roman\",\n    \"opacity\": 0.85\n  }\n}\n</code></pre>"},{"location":"manifests/","title":"App Manifests","text":"<p>There are many times in which you may need to parameterize an AndroidManifest.xml or Info.plist. One such example would be when using the MSAL library for Azure Active Directory / Azure Active Directory B2C user authentication in which you must create a custom url scheme like:</p> <pre><code>&lt;key&gt;CFBundleURLTypes&lt;/key&gt;\n&lt;array&gt;\n  &lt;dict&gt;\n    &lt;key&gt;CFBundleTypeRole&lt;/key&gt;\n    &lt;string&gt;Editor&lt;/string&gt;\n    &lt;key&gt;CFBundleURLName&lt;/key&gt;\n    &lt;string&gt;com.avantipoint.awesomeapp&lt;/string&gt;\n    &lt;key&gt;CFBundleURLSchemes&lt;/key&gt;\n    &lt;array&gt;\n      &lt;string&gt;msal$AzureADClientId$&lt;/string&gt;\n    &lt;/array&gt;\n  &lt;/dict&gt;\n&lt;/array&gt;\n</code></pre> <p>We can now leave our Info.plist or AndroidManifest.xml checked into source control and in place in our project. The Mobile.BuildTools will intelligently replace any tokenized values like the one above during the build.</p> <pre><code>{\n  \"$schema\": \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\",\n  \"manifests\": {\n    \"token\": \"$$\",\n    \"variablePrefix\": \"Manifest_\",\n    \"missingTokensAsErrors\": false,\n    \"disable\": false\n  },\n</code></pre> <p>Note</p> <p>If no environment variable can be found matching <code>Manifest_</code> as the prefix is defined, the Mobile.BuildTools will next search for a variable name matching the token name which would be <code>AzureADClientId</code> in the sample above. It will also try to do all matches case insensitive due to the issue with some build agents running <code>ToUpper()</code> on all variable names.</p> <p>Info</p> <p>In order to work with the tokenized manifest locally without having to update your Environment Variables on your developer machine, you can simply drop in a <code>manifest.json</code> in the Project root with the Key/Value pairs for the Mobile.BuildTools to use. If using this file, be sure to add it to the .gitignore so as to not accidentally check it into source control.</p>"},{"location":"manifests/#setting-the-variables","title":"Setting the Variables","text":"<p>The Mobile.BuildTools attempts to locate the values for your Manifest tokens through several sources. In the event that a variable key is duplicated, the Mobile.BuildTools has a precedence that the last one in wins. Variables are loaded from the following sources:</p> <ol> <li>buildtools.json Environment Defaults</li> <li>buildtools.json Environment Configuration (i.e. Debug, Release)</li> <li>System Environment</li> <li>Recursively load legacy <code>secrets.json</code> from the Project directory to the Solution directory</li> <li>Recursively load <code>appsettings.json</code> from the Project directory to the Solution directory</li> </ol>"},{"location":"manifests/versioning/","title":"Build Versioning","text":"<p>Build versioning can be extremely important for analytics and diagnostics. What's more is that Mobile development requires unique builds. No longer can you be lazy and ship apps for 15 years at Version 1.0.0.0. Ok technically all of your binaries in the application all will show that version, but the app itself must have a unique build number to allow you to upload to the App Store and Google Play.</p> <pre><code>{\n  \"$schema\": \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\",\n  \"automaticVersioning\": {\n    \"behavior\": \"PreferBuildNumber\",\n    \"environment\": \"All\",\n    \"versionOffset\": 0,\n    \"disable\": false\n  },\n}\n</code></pre> <p>Automatic Build Versioning supports the following Versioning Environments:</p> Environment Description All Versioning will occur on every build. BuildHost Versioning will only occur if a *Supported Build Host is detected. Local Versioning will only occur if a *Supported Build Host is not detected. <p>Automatic Build Versioning supports the following <code>Behavior</code>'s:</p> Behavior Description Off Automatic Versioning is Disabled PreferBuildNumber When running on a *Supported Build Host it will use the Build Number, otherwise it will use the current timestamp Timestamp Automatic Versioning will use the timestamp for the build <p>* Supported Build Hosts:</p> <ul> <li>AppCenter</li> <li>AppVeyor</li> <li>Azure DevOps</li> <li>Jenkins</li> </ul> <p>Info</p> <p>You might use the <code>versionOffset</code> when your CI Build Number and Build Number in the App Store or Google Play are not in sync. As an example, when shipping multiple APKs with the same build number Google Play may take build 123 and make it 100123, 200123, 300123, &amp; 400123 respectively for each of the 4 APK's you have provided. This would mean when switching to AAB that you might need to offset by 400000 in order to get your new AAB build to show up in Google Play.</p>"},{"location":"manifests/versioning/#planned-enhancements","title":"Planned Enhancements","text":"<p>Build Versioning is a brand new task that has been planned for a long time and sadly has taken a lot longer to get implemented than what was originally anticipated. Beginning with the push for 2.1 we will be looking at more advanced scenarios:</p> <ul> <li>Support scenarios where you may want to control a public display version like 1.0 but need a unique build id so that you can resubmit to the store if the App Store or Google Play reject your app during review.</li> <li>Support using GitVersioning. Git Versioning is a popular technique used by a lot of modern libraries including the Mobile.BuildTools. This occurs by evaluating the Git Height, and is generally controlled with a <code>version.json</code> in the root directory. You can look at the Mobile.BuildTools repo for an example of this using Nerdbank.GitVersioning.</li> </ul>"},{"location":"scss-to-css/","title":"SCSS to Xamarin.Forms CSS","text":"<p>While CSS support in Xamarin.Forms has been a highly controversial topic in which you likely either love it or hate it, it has been my view that CSS support in Xamarin.Forms is the most revolutionary change to Styling XAML. CSS though is traditionally problematic on larger projects as it can quickly become hard to maintain, and error prone as it lacks reusability of common values which could include setting various properties or reusing the same color from one element to the next. With SCSS you gain the ability to break your stylesheets into logical reusable chunks and you gain the ability to define variables and functions for creating your styles. For those developers who want to start using CSS in their Xamarin.Forms application, the Mobile.BuildTools empowers you to leverage SCSS which is compiled into Xamarin.Forms compatible CSS at build.</p>"},{"location":"scss-to-css/#valid-xamarinforms-css","title":"Valid Xamarin.Forms CSS","text":"<p>Perhaps one of the most frustrating things about Xamarin.Forms CSS is that the spec is NOT compliant with standard CSS linting. Specifically Xamarin.Forms requires the <code>^</code> prefix when looking to have a style apply to any inheriting type which you may want to do for instance when styling a Page.</p> <pre><code>^button {\n  background-color: transparent;\n}\n\n.primary ^button {\n  background-color: #78909c;\n}\n</code></pre> <p>The Mobile.BuildTools will post process your SCSS to generate valid CSS for Xamarin.Forms when using the selectors <code>any</code> or <code>all</code>.</p>"},{"location":"scss-to-css/#valid-scss-used-by-the-mobilebuildtools","title":"Valid SCSS used by the Mobile.BuildTools","text":"<pre><code>button:any {\n  background-color: transparent;\n}\n\n.primary button:all {\n  background-color: #78909c;\n}\n</code></pre>"},{"location":"scss-to-css/#getting-started","title":"Getting Started","text":"<p>To get started, simply add any scss format stylesheets you want to your project and make sure that the build action is set to <code>None</code>. The Mobile.BuildTools will automatically detect them and generate a CSS file for each non-partial (anything not starting with an underscore). For more information on how to get started with SCSS see the Getting Started Guide from LibSass.</p> <p>Note</p> <p>Xamarin.Forms does not support minimized files</p>"},{"location":"scss-to-css/css-notes/","title":"Usage Notes","text":""},{"location":"scss-to-css/css-notes/#supported-selectors","title":"Supported Selectors","text":"Selector Example Description .class .header Selects all elements with the StyleClass property containing 'header' #id #email Selects all elements with StyleId set to email. If StyleId is not set, fallback to x:Name. When using Xaml, always prefer x:Name over StyleId. * * Selects all elements element label Selects all elements of type Label (but not subclasses). Case irrelevant. ^base ^contentpage Selects all elements with ContentPage as base class, including ContentPage itself. Case irrelevant. This selector isn't present in the CSS specification, and only applies to XF. element,element label,button Selects all Buttons and all Labels element element stacklayout label Selects all Labels inside of a StackLayout element&gt;element stacklayout&gt;label Selects all Labels with StackLayout as a direct parent element+element label+entry Selects all Entries directly after a Label element~element label~entry Selects all Entries preceded by a Label"},{"location":"scss-to-css/css-notes/#unsupported-selectors-for-this-version","title":"Unsupported Selectors (for this version)","text":"<ul> <li><code>[attribute]</code> selectors</li> <li><code>@media</code> or <code>@supports</code> selectors</li> <li><code>:</code> or <code>::</code> selectors</li> </ul>"},{"location":"scss-to-css/css-notes/#selector-combinations","title":"Selector combinations","text":"<p>Selectors can be combined without limitation, like in StackLayout &gt; ContentView &gt; label.email. But keep it sane !</p>"},{"location":"scss-to-css/css-notes/#precedence","title":"Precedence","text":"<p>Styles with matching selectors are all applied, on by one, in definition order. Styles defined on the item itself is always applied last.</p> <p>This is the expected behavior in most cases, even if doesn't 100% match common CSS implementations.</p> <p>Specificity, and specificity overrides (<code>!important</code>) are not supported. This is a known issue.</p>"},{"location":"scss-to-css/css-notes/#unsupported-common-properties","title":"Unsupported Common Properties","text":"<ul> <li><code>all: initial</code></li> <li>layout properties (box, or grid). FlexLayout is coming, and it'll be CSS stylable,</li> <li>shorthand properties, like <code>font</code>, <code>border</code></li> </ul>"},{"location":"scss-to-css/css-notes/#colors","title":"Colors","text":"<ul> <li>one of the 140 X11 color (https://en.wikipedia.org/wiki/X11_color_names), which happens to match CSS Colors, UWP predefined colors and XF Colors. Case insensitive</li> <li>HEX: <code>#rgb</code>, <code>#argb</code>, <code>#rrggbb</code>, <code>#aarrggbb</code></li> <li>RGB: <code>rgb(255,0,0)</code>, <code>rgb(100%,0%,0%)</code> =&gt; values in range 0-255 or 0%-100%</li> <li>RGBA: <code>rgba(255, 0, 0, 0.8)</code>, <code>rgba(100%, 0%, 0%, 0.8)</code> =&gt; opacity is 0.0-1.0</li> <li>HSL: <code>hsl(120, 100%, 50%)</code> =&gt; h is 0-360, s and l are 0%-100%</li> <li>HSLA: <code>hsla(120, 100%, 50%, .8)</code> =&gt; opacity is 0.0-1.0</li> </ul>"},{"location":"scss-to-css/css-notes/#thickness","title":"Thickness","text":"<p>One, two, three or four values, separated by white spaces.</p> <ul> <li>a single value indicates uniform thickness</li> <li>two values indicates (resp.) vertical and horizontal thickness</li> <li>three values indicates (resp.) top, horizontal (left and right) and bottom thickness</li> <li>when using four values, they are top, right, bottom, left</li> </ul> <p>IMPORTANT: This differs from Xaml thickness definitions, which are</p> <ol> <li>separated by commas (<code>,</code>)</li> <li>are in the form of <code>uniform</code>, <code>horizontal</code>, <code>vertical</code> or <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code></li> </ol>"},{"location":"scss-to-css/css-notes/#namedsize","title":"NamedSize","text":"<p>One of the following value, case insensitive. Exact meaning depends of the platform and the control</p> <ul> <li><code>default</code></li> <li><code>micro</code></li> <li><code>small</code></li> <li><code>medium</code></li> <li><code>large</code></li> </ul>"},{"location":"scss-to-css/css-notes/#initial","title":"Initial","text":"<p><code>initial</code> is a valid value for all properties. It clears the value (resets to default) that was set from another Style.</p>"},{"location":"scss-to-css/css-notes/#additional-remarks","title":"Additional remarks","text":"<ul> <li>no inheritance supported, meaning no <code>inherit</code> value and that you can't set the font-size to a layout, and expect all the labels in that layout to inherit the value. The only exception is the <code>direction</code> property, which supports <code>inherit</code>, and that's the default value.</li> <li>element are matched by name, no support for xmlns</li> </ul>"},{"location":"scss-to-css/in-code/","title":"In Code","text":""},{"location":"scss-to-css/in-code/#xaml-preferred","title":"XAML (preferred)","text":"<pre><code>&lt;ContentPage x:Class=\"...\"&gt;\n  &lt;ContentPage.Resources&gt;\n    &lt;StyleSheet Source=\"appresources/style.css\" /&gt;\n  &lt;/ContentPage.Resources&gt;\n&lt;/ContentPage&gt;\n</code></pre> <p>the <code>Source</code> argument takes an Uri relative to the current xaml control, or relative to the application root if it starts with a <code>/</code>. The <code>style.css</code> has to be an EmbeddedResource.</p> <p>alternatively, you can inline your style in a <code>CDATA</code> Section</p> <pre><code>&lt;ContentPage x:Class=\"...\"&gt;\n  &lt;ContentPage.Resources&gt;\n    &lt;StyleSheet&gt;\n&lt;![CDATA[\n^contentpage {\n    background-color: orange;\n    padding: 20;\n}\n\nstacklayout &gt; * {\n    margin: 3;\n}\n]]&gt;\n    &lt;/StyleSheet&gt;\n  &lt;/ContentPage.Resources&gt;\n&lt;/ContentPage&gt;\n</code></pre> <p>do not abuse that second syntax.</p>"},{"location":"scss-to-css/in-code/#in-c","title":"in C","text":"<p>From an embedded resource:</p> <pre><code>myPage.Resources.Add(StyleSheet.FromAssemblyResource(this.GetType().Assembly, \"resource.id.of.the.css\"));\n</code></pre> <p>or from a TextReader:</p> <pre><code>using (var reader = new StringReader(my_css_string))\n    myPage.Resources.Add(StyleSheet.FromReader(reader));\n</code></pre>"},{"location":"scss-to-css/in-code/#stylesheet-xamlc-and-other-potential-optimizations","title":"StyleSheet, XamlC and other potential optimizations","text":"<p>At this time, CSS StyleSheets are parsed and evaluated at runtime. That aren't compiled. Every time a StyleSheet is used, it's reparsed again. If parsing time is an issue, enabling caching is trivial, but comes at memory cost.</p>"},{"location":"scss-to-css/properties/","title":"Supported Properties","text":"Property Applies To Value Type / Info <code>background-color</code> <code>VisualElement</code> BackgroundColorProperty <code>background-image</code> <code>Page</code> BackgroundImageSourceProperty <code>border-color</code> <code>IBorderElement</code> BorderColorProperty <code>border-radius</code> <code>ICornerElement</code> CornerRadiusProperty <code>border-radius</code> <code>Button</code> CornerRadiusProperty <code>border-radius</code> <code>Frame</code> CornerRadiusProperty <code>border-radius</code> <code>ImageButton</code> CornerRadiusProperty <code>border-width</code> <code>IBorderElement</code> BorderWidthProperty <code>color</code> <code>IColorElement</code> ColorProperty, Inherited = true <code>color</code> <code>ITextElement</code> TextColorProperty, Inherited = true <code>color</code> <code>ProgressBar</code> ProgressBar.ProgressColorProperty <code>color</code> <code>Switch</code> OnColorProperty <code>column-gap</code> <code>Grid</code> ColumnSpacingProperty <code>direction</code> <code>VisualElement</code> FlowDirectionProperty, Inherited = true <code>font-family</code> <code>IFontElement</code> FontFamilyProperty, Inherited = true <code>font-size</code> <code>IFontElement</code> FontSizeProperty, Inherited = true <code>font-style</code> <code>IFontElement</code> FontAttributesProperty, Inherited = true <code>height</code> <code>VisualElement</code> HeightRequestProperty <code>margin</code> <code>View</code> View.MarginProperty <code>margin-left</code> <code>View</code> View.MarginLeftProperty <code>margin-top</code> <code>View</code> View.MarginTopProperty <code>margin-right</code> <code>View</code> View.MarginRightProperty <code>margin-bottom</code> <code>View</code> View.MarginBottomProperty <code>max-lines</code> <code>Label</code> Label.MaxLinesProperty <code>min-height</code> <code>VisualElement</code> MinimumHeightRequestProperty <code>min-width</code> <code>VisualElement</code> MinimumWidthRequestProperty <code>opacity</code> <code>VisualElement</code> OpacityProperty <code>padding</code> <code>IPaddingElement</code> PaddingProperty <code>padding-left</code> <code>IPaddingElement</code> PaddingLeftProperty, PropertyOwnerType = PaddingElement <code>padding-top</code> <code>IPaddingElement</code> PaddingTopProperty, PropertyOwnerType = PaddingElement <code>padding-right</code> <code>IPaddingElement</code> PaddingRightProperty, PropertyOwnerType = PaddingElement <code>padding-bottom</code> <code>IPaddingElement</code> PaddingBottomProperty, PropertyOwnerType = PaddingElement <code>row-gap</code> <code>Grid</code> RowSpacingProperty <code>text-align</code> <code>ITextAlignmentElement</code> HorizontalTextAlignmentProperty, Inherited = true <code>text-decoration</code> <code>IDecorableTextElement</code> DecorableTextElement.TextDecorationsProperty <code>transform</code> <code>VisualElement</code> TransformProperty <code>transform-origin</code> <code>VisualElement</code> TransformOriginProperty <code>vertical-align</code> <code>ITextAlignmentElement</code> VerticalTextAlignmentProperty <code>visibility</code> <code>VisualElement</code> IsVisibleProperty, Inherited = true <code>width</code> <code>VisualElement</code> WidthRequestProperty <code>letter-spacing</code> <code>ITextElement</code> CharacterSpacingProperty, Inherited = true <code>line-height</code> <code>ILineHeightElement</code> LineHeightProperty, Inherited = true"},{"location":"scss-to-css/properties/#flexlayout","title":"FlexLayout","text":"Property Applies To Value Type / Info <code>align-content</code> <code>FlexLayout</code> AlignContentProperty <code>align-items</code> <code>FlexLayout</code> AlignItemsProperty <code>align-self</code> <code>VisualElement</code> AlignSelfProperty, PropertyOwnerType = FlexLayout <code>flex-direction</code> <code>FlexLayout</code> DirectionProperty <code>flex-basis</code> <code>VisualElement</code> BasisProperty, PropertyOwnerType = FlexLayout <code>flex-grow</code> <code>VisualElement</code> GrowProperty, PropertyOwnerType = FlexLayout <code>flex-shrink</code> <code>VisualElement</code> ShrinkProperty, PropertyOwnerType = FlexLayout <code>flex-wrap</code> <code>VisualElement</code> WrapProperty, PropertyOwnerType = FlexLayout <code>justify-content</code> <code>FlexLayout</code> JustifyContentProperty <code>order</code> <code>VisualElement</code> OrderProperty, PropertyOwnerType = FlexLayout <code>position</code> <code>FlexLayout</code> PositionProperty"},{"location":"scss-to-css/properties/#xamarinforms-specific-properties","title":"Xamarin.Forms Specific Properties","text":"Property Applies To Value Type / Info <code>-xf-placeholder</code> <code>IPlaceholderElement</code> PlaceholderProperty <code>-xf-placeholder-color</code> <code>IPlaceholderElement</code> PlaceholderColorProperty <code>-xf-max-length</code> <code>InputView</code> MaxLengthProperty <code>-xf-bar-background-color</code> <code>IBarElement</code> BarBackgroundColorProperty <code>-xf-bar-text-color</code> <code>IBarElement</code> BarTextColorProperty <code>-xf-orientation</code> <code>ScrollView</code> OrientationProperty <code>-xf-horizontal-scroll-bar-visibility</code> <code>ScrollView</code> HorizontalScrollBarVisibilityProperty <code>-xf-vertical-scroll-bar-visibility</code> <code>ScrollView</code> VerticalScrollBarVisibilityProperty <code>-xf-min-track-color</code> <code>Slider</code> MinimumTrackColorProperty <code>-xf-max-track-color</code> <code>Slider</code> MaximumTrackColorProperty <code>-xf-thumb-color</code> <code>Slider</code> ThumbColorProperty <code>-xf-spacing</code> <code>StackLayout</code> SpacingProperty <code>-xf-orientation</code> <code>StackLayout</code> OrientationProperty <code>-xf-visual</code> <code>VisualElement</code> VisualProperty <code>-xf-vertical-text-alignment</code> <code>Label</code> VerticalTextAlignmentProperty <code>-xf-thumb-color</code> <code>Switch</code> ThumbColorProperty"},{"location":"scss-to-css/properties/#shell-specific-properties","title":"Shell Specific Properties","text":"Property Applies To Value Type / Info <code>-xf-flyout-background</code> <code>Shell</code> FlyoutBackgroundColorProperty <code>-xf-shell-background</code> <code>Element</code> BackgroundColorProperty, PropertyOwnerType = Shell <code>-xf-shell-disabled</code> <code>Element</code> DisabledColorProperty, PropertyOwnerType = Shell <code>-xf-shell-foreground</code> <code>Element</code> ForegroundColorProperty, PropertyOwnerType = Shell <code>-xf-shell-tabbar-background</code> <code>Element</code> TabBarBackgroundColorProperty, PropertyOwnerType = Shell <code>-xf-shell-tabbar-disabled</code> <code>Element</code> TabBarDisabledColorProperty, PropertyOwnerType = Shell <code>-xf-shell-tabbar-foreground</code> <code>Element</code> TabBarForegroundColorProperty, PropertyOwnerType = Shell <code>-xf-shell-tabbar-title</code> <code>Element</code> TabBarTitleColorProperty, PropertyOwnerType = Shell <code>-xf-shell-tabbar-unselected</code> <code>Element</code> TabBarUnselectedColorProperty, PropertyOwnerType = Shell <code>-xf-shell-title</code> <code>Element</code> TitleColorProperty, PropertyOwnerType = Shell <code>-xf-shell-unselected</code> <code>Element</code> UnselectedColorProperty, PropertyOwnerType = Shell"}]}
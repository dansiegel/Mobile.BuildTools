{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started \u00b6 The Mobile.BuildTools is an easy to use NuGet package that adds new MSBuild targets to your build pipeline. In essence it teaches MSBuild some new tricks to help make your DevOps easier and help you follow better practices while developing your application. The bulk of support is around Xamarin.Android and Xamarin.iOS and it will work regardless of whether you are using the native tooling, Xamarin.Forms, or Uno to create your UI. The Mobile.BuildTools are a collection of MSBuild Tasks that help make MSBuild smarter in handling the build process for CI/CD with Mobile Applications. The library was born from a desire to share build processes from one app to the next without having to copy and paste a bunch of build scripts each of which could easily end up out of date. Because the Mobile.BuildTools simply provides MSBuild Tasks, this adds nothing to the size of your application and if being used on a project that will be packed and shared, you can set the PackageReference's PrivateAssets to all. NOTE The docs on this site are specific to the Mobile.BuildTools v2.0. For those still using v1.4 please refer to the Wiki on GitHub. History \u00b6 The Mobile.BuildTools started out several years ago from powershell scripts I found myself writing from one project to the next to help me decouple app secrets and configuration values from the code base making these instead build time dependencies. Over the years this grew from the scripts I kept re-writing to scripts that I included out of the box with the Prism Quickstart templates. These features had nothing to do with Prism however, and I started looking at how these could be re-used for any Xamarin application. With that the Mobile.BuildTools was born. Over the years it has grown and had so many features added that I ultimately realized I better start writing a docs site as it has a solution for pretty much every problem I encounter when developing mobile apps. Support \u00b6 This project is maintained by Dan Siegel. If this project has helped you please consider sponsoring Dan on GitHub. Your contributions help make great open source projects possible. Note Enterprise Support is available through AvantiPoint . Please reach out if you require support for your apps with the Mobile.BuildTools, Prism or general assistance with your Xamarin, .NET Maui, or Uno Platform apps. Latest NuGet's \u00b6 Package NuGet SponsorConnect Mobile.BuildTools Mobile.BuildTools.Configuration Want to consume the CI packages? Sign up as a GitHub sponsor and you can access the Sponsor Connect private feed. Why Use the Mobile.BuildTools \u00b6 The Mobile.BuildTools is designed to help you with a variety of tasks that make mobile app development easier and help you to follow best practices keeping app secrets as well as environment configurations out of your source control. Additionally the Mobile.BuildTools has a variety of helpers that can help you manage your image resources, white label apps, or generally make it easier to build your app for side by side installation for different environments like Dev, Stage, and Production. What does it do? \u00b6 Automatic app bundle copy to artifacts folder in the Solution directory On iOS this copies your IPA + dSYM On Android this copies your APK / AAB Automatically update the app version Configurable for local, build host or both Configurable to use timestamp or BuildId if it exists + user defined Offset Tokenize your Info.plist / AndroidManifest.xml ( $$SomeKey$$ ) Tokens replaced at build in obj to protect any against configuration values being checked in Support for SCSS files to generate Xamarin.Forms CSS files Generate 'AppSettings' class at build that contains any configuration or application secrets Supports all primitive data types + Uri, DateTime, DateTimeOffset, TimeStamp, & Guid Any property can be made an array of values (useful for feature flags or OAuth scopes) ConfigurationManager with app.config Optimized for Mobile with familiar Static API and Interface based Singleton Offers Opt-In API for doing runtime transformations and bundling app.config's App.config transformations at build Optionally bundle all config's or config's with Non-Standard environment (i.e. not Debug, Release) Simplified Image Handling (Android, iOS, macOS, tvOS) Ability to store single high resolution images in one or more directories Ability to conditionally include images in directories based on the build target (i.e. iOS or Android) Ability to conditionally include images in directories based on the build configuration (i.e. Debug or !Debug) Ability to include images that may only be used as an overlay for another image. Ability to Draw Banner on images (i.e. Dev, Debug, Free, Pro) User controlled Text User controlled Text color & Font from System Font or local font file User control Banner color.. can include a single color for a solid look, or multiple colors for a gradient Ability to generate additional outputs for a single input image Ability add padding around an image Ability to add a background color to a transparent image Supports PNG & JPG file types Support for SVG and Gif (Planned) Release Notes generation Customizable output based on latest commit messages (Planned) Support for user templating and Flag based messages since last release/Git Tag... (i.e. [Bug][iOS] Some bug got fixed ) Additional Notes \u00b6 Some additional notes... the Mobile.BuildTools will help with some advanced scenarios like: Generating app bundles that have different ID's for different environments White Labeling Use the Secrets to generate Feature Flags Generate Free or Lite versions of your app along with a Pro version Using the image api you could have a single input image and generate each of the following All of the outputs defined for the AppIcon iconset on iOS A typical BundleResource 1x, 2x, 3x for using in your SplashScreen storyboard A typical Drawable for you a splash screen activity (ldpi, mdpi, hdpi, xhdpi, xxhdpi, xxxhdpi) The smaller icon file in the mipmap folders (ldpi, mdpi, hdpi, xhdpi, xxhdpi, xxxhdpi) The larger launcher_foreground file in the mipmap folders (ldpi, mdpi, hdpi, xhdpi, xxhdpi, xxxhdpi)","title":"Getting Started"},{"location":"#getting-started","text":"The Mobile.BuildTools is an easy to use NuGet package that adds new MSBuild targets to your build pipeline. In essence it teaches MSBuild some new tricks to help make your DevOps easier and help you follow better practices while developing your application. The bulk of support is around Xamarin.Android and Xamarin.iOS and it will work regardless of whether you are using the native tooling, Xamarin.Forms, or Uno to create your UI. The Mobile.BuildTools are a collection of MSBuild Tasks that help make MSBuild smarter in handling the build process for CI/CD with Mobile Applications. The library was born from a desire to share build processes from one app to the next without having to copy and paste a bunch of build scripts each of which could easily end up out of date. Because the Mobile.BuildTools simply provides MSBuild Tasks, this adds nothing to the size of your application and if being used on a project that will be packed and shared, you can set the PackageReference's PrivateAssets to all. NOTE The docs on this site are specific to the Mobile.BuildTools v2.0. For those still using v1.4 please refer to the Wiki on GitHub.","title":"Getting Started"},{"location":"#history","text":"The Mobile.BuildTools started out several years ago from powershell scripts I found myself writing from one project to the next to help me decouple app secrets and configuration values from the code base making these instead build time dependencies. Over the years this grew from the scripts I kept re-writing to scripts that I included out of the box with the Prism Quickstart templates. These features had nothing to do with Prism however, and I started looking at how these could be re-used for any Xamarin application. With that the Mobile.BuildTools was born. Over the years it has grown and had so many features added that I ultimately realized I better start writing a docs site as it has a solution for pretty much every problem I encounter when developing mobile apps.","title":"History"},{"location":"#support","text":"This project is maintained by Dan Siegel. If this project has helped you please consider sponsoring Dan on GitHub. Your contributions help make great open source projects possible. Note Enterprise Support is available through AvantiPoint . Please reach out if you require support for your apps with the Mobile.BuildTools, Prism or general assistance with your Xamarin, .NET Maui, or Uno Platform apps.","title":"Support"},{"location":"#latest-nugets","text":"Package NuGet SponsorConnect Mobile.BuildTools Mobile.BuildTools.Configuration Want to consume the CI packages? Sign up as a GitHub sponsor and you can access the Sponsor Connect private feed.","title":"Latest NuGet's"},{"location":"#why-use-the-mobilebuildtools","text":"The Mobile.BuildTools is designed to help you with a variety of tasks that make mobile app development easier and help you to follow best practices keeping app secrets as well as environment configurations out of your source control. Additionally the Mobile.BuildTools has a variety of helpers that can help you manage your image resources, white label apps, or generally make it easier to build your app for side by side installation for different environments like Dev, Stage, and Production.","title":"Why Use the Mobile.BuildTools"},{"location":"#what-does-it-do","text":"Automatic app bundle copy to artifacts folder in the Solution directory On iOS this copies your IPA + dSYM On Android this copies your APK / AAB Automatically update the app version Configurable for local, build host or both Configurable to use timestamp or BuildId if it exists + user defined Offset Tokenize your Info.plist / AndroidManifest.xml ( $$SomeKey$$ ) Tokens replaced at build in obj to protect any against configuration values being checked in Support for SCSS files to generate Xamarin.Forms CSS files Generate 'AppSettings' class at build that contains any configuration or application secrets Supports all primitive data types + Uri, DateTime, DateTimeOffset, TimeStamp, & Guid Any property can be made an array of values (useful for feature flags or OAuth scopes) ConfigurationManager with app.config Optimized for Mobile with familiar Static API and Interface based Singleton Offers Opt-In API for doing runtime transformations and bundling app.config's App.config transformations at build Optionally bundle all config's or config's with Non-Standard environment (i.e. not Debug, Release) Simplified Image Handling (Android, iOS, macOS, tvOS) Ability to store single high resolution images in one or more directories Ability to conditionally include images in directories based on the build target (i.e. iOS or Android) Ability to conditionally include images in directories based on the build configuration (i.e. Debug or !Debug) Ability to include images that may only be used as an overlay for another image. Ability to Draw Banner on images (i.e. Dev, Debug, Free, Pro) User controlled Text User controlled Text color & Font from System Font or local font file User control Banner color.. can include a single color for a solid look, or multiple colors for a gradient Ability to generate additional outputs for a single input image Ability add padding around an image Ability to add a background color to a transparent image Supports PNG & JPG file types Support for SVG and Gif (Planned) Release Notes generation Customizable output based on latest commit messages (Planned) Support for user templating and Flag based messages since last release/Git Tag... (i.e. [Bug][iOS] Some bug got fixed )","title":"What does it do?"},{"location":"#additional-notes","text":"Some additional notes... the Mobile.BuildTools will help with some advanced scenarios like: Generating app bundles that have different ID's for different environments White Labeling Use the Secrets to generate Feature Flags Generate Free or Lite versions of your app along with a Pro version Using the image api you could have a single input image and generate each of the following All of the outputs defined for the AppIcon iconset on iOS A typical BundleResource 1x, 2x, 3x for using in your SplashScreen storyboard A typical Drawable for you a splash screen activity (ldpi, mdpi, hdpi, xhdpi, xxhdpi, xxxhdpi) The smaller icon file in the mipmap folders (ldpi, mdpi, hdpi, xhdpi, xxhdpi, xxxhdpi) The larger launcher_foreground file in the mipmap folders (ldpi, mdpi, hdpi, xhdpi, xxhdpi, xxxhdpi)","title":"Additional Notes"},{"location":"configuration/","text":"The Mobile.BuildTools relies a lot on JSON configurations because JSON is easy for most developers to work with. FileName Schema Url appsettings.json n/a - JSON Dictionary buildtools.json https://mobilebuildtools.com/schemas/v2/buildtools.schema.json {imageName}.json https://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json appsettings.json \u00b6 Everyone has a different opinion of how they would like to set things up. While the Mobile.BuildTools is opinionated in certain ways, we also try to make efforts to meet developers where their needs are giving you some flexibility in configuration. Within a CI environment, the Mobile.BuildTools relies on Environment Variables to map values you need in your app. However this is a bit of a pain to deal with for local app development. The Mobile.BuildTools has long relied on a secrets.json file containing the dictionary values of the various variables you need for your build. With version 2.0 we have deprecated secrets.json in favor of appsettings.json . Additionally we hav added a few benefits to this allowing you to now pick and choose which file directory you would like the appsettings.json to live in. This can be any directory from the directory where your Solution file is located up to the Project directory. This can be particularly helpful when you may be using the Mobile.BuildTools to supply values across multiple projects or even where you may be replacing certain values in your AndroidManifest.xml or Info.plist. BuildTools.json \u00b6 One of the biggest changes in the Mobile.BuildTools 2.0 is the introduction of the buildtools.json . Because we provide an easy to use json configuration with a Json Schema you have the ability to get intellisense in Visual Studio, Visual Studio Code, as well as many other editors that support Json Schemas. This makes it much easier for you to configure the Mobile.BuildTools rather than relying on MSBuild properties which can confuse many developers. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" } Note Some features may still utilize MSBuild parameters which can be defined in your CI Build to customize behavior during a CI build. An example of this would be an override to the Image search paths which can be particularly useful for White Labeling apps. Image Configuration Json \u00b6 The Images API for the Mobile.BuildTools is incredibly powerful and dynamic. One of the ways that we support powerful image creation is by incorporating a configuration file for each image. By convention the configuration file should have the same file name (minus the file extension) of the image resource. You can then customize the output image resource name. This can be done globally or be specific on a specific platform like iOS or Android. Additionally you can configure a single input image to have multiple outputs. An example of this scenario could be that you have a resource that will be used for the App Icon. On Android you may output both the standard image and the \"Launcher\" image which may have additional padding to look good as a round icon.","title":"Configuration"},{"location":"configuration/#appsettingsjson","text":"Everyone has a different opinion of how they would like to set things up. While the Mobile.BuildTools is opinionated in certain ways, we also try to make efforts to meet developers where their needs are giving you some flexibility in configuration. Within a CI environment, the Mobile.BuildTools relies on Environment Variables to map values you need in your app. However this is a bit of a pain to deal with for local app development. The Mobile.BuildTools has long relied on a secrets.json file containing the dictionary values of the various variables you need for your build. With version 2.0 we have deprecated secrets.json in favor of appsettings.json . Additionally we hav added a few benefits to this allowing you to now pick and choose which file directory you would like the appsettings.json to live in. This can be any directory from the directory where your Solution file is located up to the Project directory. This can be particularly helpful when you may be using the Mobile.BuildTools to supply values across multiple projects or even where you may be replacing certain values in your AndroidManifest.xml or Info.plist.","title":"appsettings.json"},{"location":"configuration/#buildtoolsjson","text":"One of the biggest changes in the Mobile.BuildTools 2.0 is the introduction of the buildtools.json . Because we provide an easy to use json configuration with a Json Schema you have the ability to get intellisense in Visual Studio, Visual Studio Code, as well as many other editors that support Json Schemas. This makes it much easier for you to configure the Mobile.BuildTools rather than relying on MSBuild properties which can confuse many developers. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" } Note Some features may still utilize MSBuild parameters which can be defined in your CI Build to customize behavior during a CI build. An example of this would be an override to the Image search paths which can be particularly useful for White Labeling apps.","title":"BuildTools.json"},{"location":"configuration/#image-configuration-json","text":"The Images API for the Mobile.BuildTools is incredibly powerful and dynamic. One of the ways that we support powerful image creation is by incorporating a configuration file for each image. By convention the configuration file should have the same file name (minus the file extension) of the image resource. You can then customize the output image resource name. This can be done globally or be specific on a specific platform like iOS or Android. Additionally you can configure a single input image to have multiple outputs. An example of this scenario could be that you have a resource that will be used for the App Icon. On Android you may output both the standard image and the \"Launcher\" image which may have additional padding to look good as a round icon.","title":"Image Configuration Json"},{"location":"credits/","text":"While the Mobile.BuildTools does not add any external dependencies to your projects, we could not do what we do without being able to build on the hard work from other projects. Though the Mobile.BuildTools is licensed under the MIT License, some of our dependencies use alternate Open Source licenses. Project License GitHub MSBuild MIT microsoft/msbuild Newtonsoft.Json MIT JamesNK/Newtonsoft.Json Microsoft.Web.Xdt* Apache aspnet/xdt Svg.Skia MIT wieslawsoltes/Svg.Skia SkiaSharp MIT mono/SkiaSharp Note Microsoft.Web.Xdt is the only reference added to projects, if using the Mobile.BuildTools.Configuration package. There is never any bloat added by the core Mobile.BuildTools package to your applications. Despite being from the aspnet team this package does not bring in any additional references.","title":"Credits"},{"location":"faq/","text":"F.A.Q. \u00b6 Should every value in my AppSettings be \"Secret\"? \u00b6 The AppSettings Class is a great way to prevent security vulnerabilities created from checking into source control things like Client Id's, Consumer Secrets, or Connection Strings. But it really doesn't have to stop there. In fact the AppSettings class is a great way of setting the configuration environment for your application at build. Should your build point to the Dev, Stage, or Production API? This is also a great way of being very intentional about it. Does the AppSettings class have to be in the Helpers namespace or named Secrets? \u00b6 In short no it does not. This has always been configurable though it is much easier with version 2.0 as you can just update the Configuration for the project. See the App Settings Configuration topic for more information on how to configure this for version 2. Do all of the things that the Mobile.BuildTools is capable of execute every time I run a build? \u00b6 We try to be smart about what we will and will not do. There is an initialization task that will run on each build which evaluates your project to determine if certain things should or should not occur. For instance if there are no SCSS files in your project that Target will not fire, similarly if you have disabled a target explicitly it should be skipped during the build. I installed the Mobile.BuildTools why can't I access the ConfigurationManager? \u00b6 We explicitly separated the ConfigurationManager from the Mobile.BuildTools as we recognize that not everyone will want to use this feature. In order to get the build time transformations you will need to have the Mobile.BuildTools installed in your platform projects, however you will need the Mobile.BuildTools.Configuration package installed in any project where you want to use the ConfigurationManager.","title":"F.A.Q."},{"location":"faq/#faq","text":"","title":"F.A.Q."},{"location":"faq/#should-every-value-in-my-appsettings-be-secret","text":"The AppSettings Class is a great way to prevent security vulnerabilities created from checking into source control things like Client Id's, Consumer Secrets, or Connection Strings. But it really doesn't have to stop there. In fact the AppSettings class is a great way of setting the configuration environment for your application at build. Should your build point to the Dev, Stage, or Production API? This is also a great way of being very intentional about it.","title":"Should every value in my AppSettings be \"Secret\"?"},{"location":"faq/#does-the-appsettings-class-have-to-be-in-the-helpers-namespace-or-named-secrets","text":"In short no it does not. This has always been configurable though it is much easier with version 2.0 as you can just update the Configuration for the project. See the App Settings Configuration topic for more information on how to configure this for version 2.","title":"Does the AppSettings class have to be in the Helpers namespace or named Secrets?"},{"location":"faq/#do-all-of-the-things-that-the-mobilebuildtools-is-capable-of-execute-every-time-i-run-a-build","text":"We try to be smart about what we will and will not do. There is an initialization task that will run on each build which evaluates your project to determine if certain things should or should not occur. For instance if there are no SCSS files in your project that Target will not fire, similarly if you have disabled a target explicitly it should be skipped during the build.","title":"Do all of the things that the Mobile.BuildTools is capable of execute every time I run a build?"},{"location":"faq/#i-installed-the-mobilebuildtools-why-cant-i-access-the-configurationmanager","text":"We explicitly separated the ConfigurationManager from the Mobile.BuildTools as we recognize that not everyone will want to use this feature. In order to get the build time transformations you will need to have the Mobile.BuildTools installed in your platform projects, however you will need the Mobile.BuildTools.Configuration package installed in any project where you want to use the ConfigurationManager.","title":"I installed the Mobile.BuildTools why can't I access the ConfigurationManager?"},{"location":"maui/","text":".NET Maui is the evolution of Xamarin. There is a lot to be excited about with .NET Maui. While this is still early days with .NET Maui and I have not yet had time to evaluate the Mobile.BuildTools with .NET Maui, there is also no reason why the Mobile.BuildTools would not work with .NET Maui. Many of the features included with the Mobile.BuildTools such as the Secrets API, is completely cross platform and can be used with literally any C# project including AspNetCore, Unit Tests, etc. For Platform Specific functionality such as the Image or Manifest processing, these rely on the iOS/Android SDK's which are shared by traditional Xamarin applications and .NET Maui apps. As such these should continue to work. If you encounter any issue with the Mobile.BuildTools and a .NET Maui application please be sure to file and issue on GitHub.","title":".NET Maui"},{"location":"release-notes/","text":"Release Notes \u00b6 Generating Release notes can be painful. The Mobile.BuildTools will help solve this problem in v2.X with the Release Notes Task. For this we will generate a ReleaseNotes.txt automatically for you. The configuration options are shown here with their default values. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"releaseNotes\" : { \"maxDays\" : 7 , \"maxCommit\" : 10 , \"characterLimit\" : 250 , \"filename\" : \"ReleaseNotes.txt\" , \"createInRoot\" : true , \"disable\" : false } }","title":"Release Note Generation"},{"location":"release-notes/#release-notes","text":"Generating Release notes can be painful. The Mobile.BuildTools will help solve this problem in v2.X with the Release Notes Task. For this we will generate a ReleaseNotes.txt automatically for you. The configuration options are shown here with their default values. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"releaseNotes\" : { \"maxDays\" : 7 , \"maxCommit\" : 10 , \"characterLimit\" : 250 , \"filename\" : \"ReleaseNotes.txt\" , \"createInRoot\" : true , \"disable\" : false } }","title":"Release Notes"},{"location":"appendix/aps/","text":"Apple Push Notifications \u00b6 When using Push Notifications on iOS you must be sure to set the aps-environment from development to production before submitting to the App Store. The Mobile.BuildTools will handle this for you easily at build. Critical Note While this was originally slated for v2.0, this will not be done until 2.1. From the Build Definition \u00b6 You can accomplish this easily by updating your build definition to pass additional MSBuild arguments with the value /p:APSProductionEnvironment=true and the Mobile.BuildTools will automatically update the aps-environment for you. - task : XamariniOS@2 inputs : solutionFile : '**/*.sln' configuration : 'Store' packageApp : true runNugetRestore : false args : '/p:APSProductionEnvironment=true' From the MSBuild Properties \u00b6 You can alternatively do this through any Directory.Build.props or in the csproj of your iOS project by adding the following: <PropertyGroup Condition= \" $(Configuration) == 'Store' \" > <APSProductionEnvironment> true </APSProductionEnvironment> </PropertyGroup>","title":"Apple Push Notifications"},{"location":"appendix/aps/#apple-push-notifications","text":"When using Push Notifications on iOS you must be sure to set the aps-environment from development to production before submitting to the App Store. The Mobile.BuildTools will handle this for you easily at build. Critical Note While this was originally slated for v2.0, this will not be done until 2.1.","title":"Apple Push Notifications"},{"location":"appendix/aps/#from-the-build-definition","text":"You can accomplish this easily by updating your build definition to pass additional MSBuild arguments with the value /p:APSProductionEnvironment=true and the Mobile.BuildTools will automatically update the aps-environment for you. - task : XamariniOS@2 inputs : solutionFile : '**/*.sln' configuration : 'Store' packageApp : true runNugetRestore : false args : '/p:APSProductionEnvironment=true'","title":"From the Build Definition"},{"location":"appendix/aps/#from-the-msbuild-properties","text":"You can alternatively do this through any Directory.Build.props or in the csproj of your iOS project by adding the following: <PropertyGroup Condition= \" $(Configuration) == 'Store' \" > <APSProductionEnvironment> true </APSProductionEnvironment> </PropertyGroup>","title":"From the MSBuild Properties"},{"location":"appendix/json-schemas/","text":"The Mobile.BuildTools relies a lot on JSON configurations because JSON is easy for most developers to work with. FileName Schema Url secrets.json n/a - JSON Dictionary DEPRECATED appsettings.json n/a - JSON Dictionary buildtools.json https://mobilebuildtools.com/schemas/v2/buildtools.schema.json {imageName}.json https://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json","title":"JSON Schemas"},{"location":"appendix/msbuild-props/","text":"MSBuild Properties \u00b6 The Mobile.BuildTools additionally provides a number of MSBuild Properties to further assist advanced developers in creating advanced build pipelines. PropertyName Description IsWindows IsUnix Indicates that you are running on a Linux or macOS build agent PowerShellExe returns the default path for the exe IsAndroidProject Indicates the current Target Framework is MonoAndroid IsiOSProject Indicates the current Target Framework is Xamarin.iOS IsUWPProject Indicates the current Target Framework is UAP IsMacOSProject Indicates the current Target Framework is Xamarin.Mac IsTizenProject Indicates the current Target Framework is Tizen BuildToolsArtifactOutputPath Will default to the Solution Directory in the App folder. In Azure DevOps it will default to the Build.ArtifactStagingDirectory again in the App folder. IsAppCenter Indicates the current build host is an App Center build agent IsAzureDevOps Indicates the current build host is an Azure DevOps build agent. IsAppVeyor Indicates the current build host is an AppVeyor build agent. IsBitBucket Indicates the current build host is a BitBucket build agent. IsGitHubActions Indicates the current build host is an GitHub Actions build agent. IsJenkins Indicates the current build host is a Jenkins build agent. IsTeamCity Indicates the current build host is a Team City build agent. IsBuildHost If any of the above CI Platforms return true this will indicate true as well.","title":"MSBuild Properties"},{"location":"appendix/msbuild-props/#msbuild-properties","text":"The Mobile.BuildTools additionally provides a number of MSBuild Properties to further assist advanced developers in creating advanced build pipelines. PropertyName Description IsWindows IsUnix Indicates that you are running on a Linux or macOS build agent PowerShellExe returns the default path for the exe IsAndroidProject Indicates the current Target Framework is MonoAndroid IsiOSProject Indicates the current Target Framework is Xamarin.iOS IsUWPProject Indicates the current Target Framework is UAP IsMacOSProject Indicates the current Target Framework is Xamarin.Mac IsTizenProject Indicates the current Target Framework is Tizen BuildToolsArtifactOutputPath Will default to the Solution Directory in the App folder. In Azure DevOps it will default to the Build.ArtifactStagingDirectory again in the App folder. IsAppCenter Indicates the current build host is an App Center build agent IsAzureDevOps Indicates the current build host is an Azure DevOps build agent. IsAppVeyor Indicates the current build host is an AppVeyor build agent. IsBitBucket Indicates the current build host is a BitBucket build agent. IsGitHubActions Indicates the current build host is an GitHub Actions build agent. IsJenkins Indicates the current build host is a Jenkins build agent. IsTeamCity Indicates the current build host is a Team City build agent. IsBuildHost If any of the above CI Platforms return true this will indicate true as well.","title":"MSBuild Properties"},{"location":"appendix/upgrade/","text":"Upgrading from 1.X \u00b6 The Mobile.BuildTools 1.X is extremely reliable for generating app secrets! But 2.0 is much better at it. There were a number of factors that went into determining what we should and should not be doing. Secrets \u00b6 There is a lot about the Secrets class generation that has been completely refactored. The result is that you have far more options when generating secrets than you did in 1.X. The big thing to consider is that you will need to add a configuration for the Project in the solution you want to add secrets for. Secrets have undergone a rename for a variety of reasons. Be sure to configure the appSettings section of the buildtools.json . For more information on how to configure this be sure to see the Configuration documentation.","title":"Upgrading from 1.X"},{"location":"appendix/upgrade/#upgrading-from-1x","text":"The Mobile.BuildTools 1.X is extremely reliable for generating app secrets! But 2.0 is much better at it. There were a number of factors that went into determining what we should and should not be doing.","title":"Upgrading from 1.X"},{"location":"appendix/upgrade/#secrets","text":"There is a lot about the Secrets class generation that has been completely refactored. The result is that you have far more options when generating secrets than you did in 1.X. The big thing to consider is that you will need to add a configuration for the Project in the solution you want to add secrets for. Secrets have undergone a rename for a variety of reasons. Be sure to configure the appSettings section of the buildtools.json . For more information on how to configure this be sure to see the Configuration documentation.","title":"Secrets"},{"location":"config/","text":"App Configuration for Mobile Projects \u00b6 Mobile Apps unlike traditional Desktop and Web projects are limiting for developers because you must define configuration values at build and not on deployment. The Mobile.BuildTools is here to help you solve this problem and meet you where you are. Developers have different needs at different times. For v1.X, the Mobile.BuildTools took the very opinionated idea that configuration values and app secrets should be treaded as something that should be strongly typed. This has a few advantages that come from errors surfacing at build time rather than runtime. Sometimes though it may be more desireable to perform quick swaps from one environment to another where you are certain that you are running the same exact tested binary build as you have previously. For this reason starting with v2.0 you will have support for using an app.config to provide you the same sort of configurations support that you may be used to from Desktop development or from the web.config variant with ASP.NET development. See Also \u00b6 Using app.config Using App Settings","title":"Intro"},{"location":"config/#app-configuration-for-mobile-projects","text":"Mobile Apps unlike traditional Desktop and Web projects are limiting for developers because you must define configuration values at build and not on deployment. The Mobile.BuildTools is here to help you solve this problem and meet you where you are. Developers have different needs at different times. For v1.X, the Mobile.BuildTools took the very opinionated idea that configuration values and app secrets should be treaded as something that should be strongly typed. This has a few advantages that come from errors surfacing at build time rather than runtime. Sometimes though it may be more desireable to perform quick swaps from one environment to another where you are certain that you are running the same exact tested binary build as you have previously. For this reason starting with v2.0 you will have support for using an app.config to provide you the same sort of configurations support that you may be used to from Desktop development or from the web.config variant with ASP.NET development.","title":"App Configuration for Mobile Projects"},{"location":"config/#see-also","text":"Using app.config Using App Settings","title":"See Also"},{"location":"config/app.config/","text":"App.config \u00b6 The Mobile.BuildTools now includes support for using an app.config. It's important to note that we do not use the System.Configuration.ConfigurationManager, and instead use a lightweight custom implementation that allows you to initialize custom configurations at runtime which may not follow the typical app.config naming or perform transformations at runtime though this is generally not a good practice. By default Mobile.BuildTools will look for any file in the root of the head project named app.config or app.*.config. All of those files will be bundled automatically into the native app. If your file has an environment config for the build configuration such as app.debug.config this will perform a transform during build on the bundled app.config. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"appConfig\" : { \"strategy\" : \"TransformOnly\" } } Note By default the Mobile.BuildTools will only bundle the transformed app.config into your project. You can optionally set the strategy to BundleAll or BundleNonStandard if you require runtime transformations. App Config Strategy \u00b6 Strategy Description TransformOnly This the default strategy which will perform the transformation and only bundle a single transformed app.config into your project. BundleAll When set as the app config strategy this will bundle any app.config that you may have such as app.debug.config or app.release.config BundleNonStandard When set as the app config strategy this will limit bundled app config's to any that are not for standard Xamarin build configurations which include Debug, Release, Store, & AdHoc. Note All file names are compared ignoring case. Supported Platforms \u00b6 Platform Supported NetStandard Yes NetCoreApp 3.1 Xamarin.iOS Yes MonoAndroid 8.0+ UWP* 16299+ Xamarin.Mac* Yes Xamarin.TVOS* Yes Tizen* Yes Note Platform's with an asterisk have not been tested explicitly. F.A.Q. \u00b6 Q. Can I use the ConfigurationManager without using the Mobile.BuildTools? A. Yes you absolutely can. The AppConfigSample project in the samples folder does exactly that! Q. How do I use the Environments? A. By default Environments are disabled. This means that we will only copy the transformed app.config into your project and the ConfigurationManager will only read the primary app.config.","title":"Intro"},{"location":"config/app.config/#appconfig","text":"The Mobile.BuildTools now includes support for using an app.config. It's important to note that we do not use the System.Configuration.ConfigurationManager, and instead use a lightweight custom implementation that allows you to initialize custom configurations at runtime which may not follow the typical app.config naming or perform transformations at runtime though this is generally not a good practice. By default Mobile.BuildTools will look for any file in the root of the head project named app.config or app.*.config. All of those files will be bundled automatically into the native app. If your file has an environment config for the build configuration such as app.debug.config this will perform a transform during build on the bundled app.config. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"appConfig\" : { \"strategy\" : \"TransformOnly\" } } Note By default the Mobile.BuildTools will only bundle the transformed app.config into your project. You can optionally set the strategy to BundleAll or BundleNonStandard if you require runtime transformations.","title":"App.config"},{"location":"config/app.config/#app-config-strategy","text":"Strategy Description TransformOnly This the default strategy which will perform the transformation and only bundle a single transformed app.config into your project. BundleAll When set as the app config strategy this will bundle any app.config that you may have such as app.debug.config or app.release.config BundleNonStandard When set as the app config strategy this will limit bundled app config's to any that are not for standard Xamarin build configurations which include Debug, Release, Store, & AdHoc. Note All file names are compared ignoring case.","title":"App Config Strategy"},{"location":"config/app.config/#supported-platforms","text":"Platform Supported NetStandard Yes NetCoreApp 3.1 Xamarin.iOS Yes MonoAndroid 8.0+ UWP* 16299+ Xamarin.Mac* Yes Xamarin.TVOS* Yes Tizen* Yes Note Platform's with an asterisk have not been tested explicitly.","title":"Supported Platforms"},{"location":"config/app.config/#faq","text":"Q. Can I use the ConfigurationManager without using the Mobile.BuildTools? A. Yes you absolutely can. The AppConfigSample project in the samples folder does exactly that! Q. How do I use the Environments? A. By default Environments are disabled. This means that we will only copy the transformed app.config into your project and the ConfigurationManager will only read the primary app.config.","title":"F.A.Q."},{"location":"config/app.config/in-code/","text":"Using It In Code \u00b6 Note that all values from the AppSettings are strings by default. Any conversions will need to be handled in your code. var foo = ConfigurationManager . AppSettings [ \"Foo\" ]; Initialization \u00b6 Before using the ConfigurationManager you must initialize it. ConfigurationManager accepts a bool to enable runtime environments, this must be set to true if you want to use configuration transforms. AppDelegate.cs public override bool FinishedLaunching ( UIApplication app , NSDictionary options ) { ConfigurationManager . Init ( true ); global :: Xamarin . Forms . Forms . Init (); LoadApplication ( new App ()); return base . FinishedLaunching ( app , options ); } MainActivity.cs protected override void OnCreate ( Bundle bundle ) { TabLayoutResource = Resource . Layout . Tabbar ; ToolbarResource = Resource . Layout . Toolbar ; base . OnCreate ( bundle ); ConfigurationManager . Init ( true , this ); global :: Xamarin . Forms . Forms . Init ( this , bundle ); LoadApplication ( new App ()); } Transformations \u00b6 While the Mobile.BuildTools will automatically perform transformations at Build, runtime transformations are also supported for those scenarios where you may need to change environments for whatever business reason. For this let's consider that we have app.config and app.foo.config . We can transform to the Foo environment as follows: var foo = ConfigurationManager . AppSettings [ \"foo\" ]; // My Foo ConfigurationManager . Transform ( \"foo\" ); // This is not case sensitive foo = ConfigurationManager . AppSettings [ \"foo\" ]; // Transformed Value To convert back you can simply call: ConfigurationManager . Reset (); Note In order to Transform the values in the ConfigurationManager at Runtime the ConfigurationManager must be initialized with the enableRuntimeEnvironments parameter set to true. ConfigurationManager.Init(true) Note Calling Transform for an Environment that does not exist will not throw an error, it will however call Reset to restore the ConfigurationManager to it's original state. Testability \u00b6 The ConfigurationManager is Interface based and utilizes a Singleton. The singleton remains constant as long as ConfigurationManager.Init() is not called. You can Reset or Transform as often as you need. As a best practice it is recommended that you register the ConfigurationManager.Current instance with a Dependency Injection container and inject the IConfigurationManager into your code. This will allow you to mock the ConfigurationManager and better test your code.","title":"In Code"},{"location":"config/app.config/in-code/#using-it-in-code","text":"Note that all values from the AppSettings are strings by default. Any conversions will need to be handled in your code. var foo = ConfigurationManager . AppSettings [ \"Foo\" ];","title":"Using It In Code"},{"location":"config/app.config/in-code/#initialization","text":"Before using the ConfigurationManager you must initialize it. ConfigurationManager accepts a bool to enable runtime environments, this must be set to true if you want to use configuration transforms. AppDelegate.cs public override bool FinishedLaunching ( UIApplication app , NSDictionary options ) { ConfigurationManager . Init ( true ); global :: Xamarin . Forms . Forms . Init (); LoadApplication ( new App ()); return base . FinishedLaunching ( app , options ); } MainActivity.cs protected override void OnCreate ( Bundle bundle ) { TabLayoutResource = Resource . Layout . Tabbar ; ToolbarResource = Resource . Layout . Toolbar ; base . OnCreate ( bundle ); ConfigurationManager . Init ( true , this ); global :: Xamarin . Forms . Forms . Init ( this , bundle ); LoadApplication ( new App ()); }","title":"Initialization"},{"location":"config/app.config/in-code/#transformations","text":"While the Mobile.BuildTools will automatically perform transformations at Build, runtime transformations are also supported for those scenarios where you may need to change environments for whatever business reason. For this let's consider that we have app.config and app.foo.config . We can transform to the Foo environment as follows: var foo = ConfigurationManager . AppSettings [ \"foo\" ]; // My Foo ConfigurationManager . Transform ( \"foo\" ); // This is not case sensitive foo = ConfigurationManager . AppSettings [ \"foo\" ]; // Transformed Value To convert back you can simply call: ConfigurationManager . Reset (); Note In order to Transform the values in the ConfigurationManager at Runtime the ConfigurationManager must be initialized with the enableRuntimeEnvironments parameter set to true. ConfigurationManager.Init(true) Note Calling Transform for an Environment that does not exist will not throw an error, it will however call Reset to restore the ConfigurationManager to it's original state.","title":"Transformations"},{"location":"config/app.config/in-code/#testability","text":"The ConfigurationManager is Interface based and utilizes a Singleton. The singleton remains constant as long as ConfigurationManager.Init() is not called. You can Reset or Transform as often as you need. As a best practice it is recommended that you register the ConfigurationManager.Current instance with a Dependency Injection container and inject the IConfigurationManager into your code. This will allow you to mock the ConfigurationManager and better test your code.","title":"Testability"},{"location":"config/app.config/transformations/","text":"Transformations \u00b6 A basic app config may look like: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <configuration> <appSettings> <add key= \"foo\" value= \"my foo\" /> <add key= \"bar\" value= \"my bar\" /> </appSettings> <connectionStrings> <add name= \"test\" providerName= \"my provider\" connectionString= \"my connection string\" /> </connectionStrings> </configuration> A Transformation config may look like: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <configuration xmlns:xdt= \"http://schemas.microsoft.com/XML-Document-Transform\" > <appSettings> <add key= \"foo\" value= \"transformed\" xdt:Transform= \"Replace\" xdt:Locator= \"Match(key)\" /> <add key= \"Environment\" value= \"Dev\" xdt:Transform= \"Insert \" /> </appSettings> </configuration> After running the transform from either the automatic build task, at runtime or with the .NET CLI Tool the resulting app.config will look like: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <configuration> <appSettings> <add key= \"foo\" value= \"transformed\" /> <add key= \"bar\" value= \"my bar\" /> <add key= \"Environment\" value= \"Dev\" /> </appSettings> <connectionStrings> <add name= \"test\" providerName= \"my provider\" connectionString= \"my connection string\" /> </connectionStrings> </configuration> XDT Transformations \u00b6 While the XDT namespace allows you to radically change your app.config. In most cases however you will only need to focus on the xdt:Transform attribute. Insert InsertBefore(XPath expression) InsertAfter(XPath expression) Remove Remove All To find out more about the available transformations, see the microsoft documentation . Replace \u00b6 This transformation requires the xdt:Locator attribute to function correctly. In most cases this will be a simple match on the key attribute: <add key= \"foo\" value= \"transformed\" xdt:Transform= \"Replace\" xdt:Locator= \"Match(key)\" /> See the documentation for all the ways in which the xdt:Locator attribute can be used.","title":"Transformations"},{"location":"config/app.config/transformations/#transformations","text":"A basic app config may look like: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <configuration> <appSettings> <add key= \"foo\" value= \"my foo\" /> <add key= \"bar\" value= \"my bar\" /> </appSettings> <connectionStrings> <add name= \"test\" providerName= \"my provider\" connectionString= \"my connection string\" /> </connectionStrings> </configuration> A Transformation config may look like: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <configuration xmlns:xdt= \"http://schemas.microsoft.com/XML-Document-Transform\" > <appSettings> <add key= \"foo\" value= \"transformed\" xdt:Transform= \"Replace\" xdt:Locator= \"Match(key)\" /> <add key= \"Environment\" value= \"Dev\" xdt:Transform= \"Insert \" /> </appSettings> </configuration> After running the transform from either the automatic build task, at runtime or with the .NET CLI Tool the resulting app.config will look like: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <configuration> <appSettings> <add key= \"foo\" value= \"transformed\" /> <add key= \"bar\" value= \"my bar\" /> <add key= \"Environment\" value= \"Dev\" /> </appSettings> <connectionStrings> <add name= \"test\" providerName= \"my provider\" connectionString= \"my connection string\" /> </connectionStrings> </configuration>","title":"Transformations"},{"location":"config/app.config/transformations/#xdt-transformations","text":"While the XDT namespace allows you to radically change your app.config. In most cases however you will only need to focus on the xdt:Transform attribute. Insert InsertBefore(XPath expression) InsertAfter(XPath expression) Remove Remove All To find out more about the available transformations, see the microsoft documentation .","title":"XDT Transformations"},{"location":"config/app.config/transformations/#replace","text":"This transformation requires the xdt:Locator attribute to function correctly. In most cases this will be a simple match on the key attribute: <add key= \"foo\" value= \"transformed\" xdt:Transform= \"Replace\" xdt:Locator= \"Match(key)\" /> See the documentation for all the ways in which the xdt:Locator attribute can be used.","title":"Replace"},{"location":"config/appsettings/","text":"Application Settings is a completely rewritten API from the legacy Secrets API. This is the evolution of the Secrets API and has an updated name to reflect the real intent as there are many time you are not actually protecting your codebase from actual application secrets as much as simply keeping configuration something that gets injected at build rather than being hard coded. Note If you were using a 2.0 preview, the BuildTools will attempt to migrate your configuration over to using the Application Settings What are AppSettings? \u00b6 We all have settings that help make our app run whether in development, staging, or production. Some examples might be Client ID's, Backend Uri's, OAuth Scopes we need. When you have any of these sorts of things you can have the Mobile.BuildTools automatically generate one or more classes in your project. Using the appsettings.json \u00b6 The Mobile.BuildTools is smart, we look for the appsettings.json in the p { \"AppCenterAppId\" : \"{your app id}\" , \"BackendUri\" : \"https://someapp.azurewebsites.net\" } Note If upgrading to 2.0 and you are using a secrets.json, the secrets.json will continue to work with a build warning. You should convert the file over to appsettings.json as support for secrets.json will be deprecated in a future release. Variable priority \u00b6 The Mobile.BuildTools attempts to locate the values for your generated class through several sources. In the event that a variable key is duplicated, the Mobile.BuildTools has a precedence that the last one in wins. Variables are loaded from the following sources buildtools.json Environment Defaults buildtools.json Environment Configuration (i.e. Debug, Release) System Environment Recursively load legacy secrets.json from the Project directory to the Solution directory Recursively load appsettings.json from the Project directory to the Solution directory Note This variable gathering is additionally used for replacing Manifest tokens","title":"Intro"},{"location":"config/appsettings/#what-are-appsettings","text":"We all have settings that help make our app run whether in development, staging, or production. Some examples might be Client ID's, Backend Uri's, OAuth Scopes we need. When you have any of these sorts of things you can have the Mobile.BuildTools automatically generate one or more classes in your project.","title":"What are AppSettings?"},{"location":"config/appsettings/#using-the-appsettingsjson","text":"The Mobile.BuildTools is smart, we look for the appsettings.json in the p { \"AppCenterAppId\" : \"{your app id}\" , \"BackendUri\" : \"https://someapp.azurewebsites.net\" } Note If upgrading to 2.0 and you are using a secrets.json, the secrets.json will continue to work with a build warning. You should convert the file over to appsettings.json as support for secrets.json will be deprecated in a future release.","title":"Using the appsettings.json"},{"location":"config/appsettings/#variable-priority","text":"The Mobile.BuildTools attempts to locate the values for your generated class through several sources. In the event that a variable key is duplicated, the Mobile.BuildTools has a precedence that the last one in wins. Variables are loaded from the following sources buildtools.json Environment Defaults buildtools.json Environment Configuration (i.e. Debug, Release) System Environment Recursively load legacy secrets.json from the Project directory to the Solution directory Recursively load appsettings.json from the Project directory to the Solution directory Note This variable gathering is additionally used for replacing Manifest tokens","title":"Variable priority"},{"location":"config/appsettings/configuration/","text":"Configuration for App Settings is a little different than for Secrets in Mobile.BuildTools 1.x. While we do provide legacy support for getting values from the secrets.json this has been almost entirely rewritten to provide much more advanced scenarios as well as to solve some issues faced in CI. CI Platform Issues \u00b6 A common problem with some build platforms such as Azure DevOps Windows Agents is that they cast all variables with ToUpper. This means that if you added MyVariable , what the Mobile.BuildTools would actually find was MYVARIABLE . With 1.x we had no way to convert this back to MyVariable for the source generation. This naturally caused a lot of problems. To solve this issue the Mobile.BuildTools now provides a configuration file that describes the projects and classes that it should generate. Configuring the buildtools.json \u00b6 The Mobile.BuildTools 2.0 configuration gives us a lot of flexibility as we can define 1 or MORE classes that should be generated automatically at build. Additionally since we can describe the class in json, we can specify exactly the data type should be rather than relying on the Mobile.BuildTools to make an educated guess. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"appSettings\" : { \"AwesomeApp\" : [ { // Your configuration here } ] } } Class Configuration \u00b6 Within the Project we can now provide any configuration values we need to either override or explicitly provide that will control how the class will be generated. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"projectSecrets\" : { \"AwesomeApp\" : [ { \"accessibility\" : \"Internal\" , \"className\" : \"AppSettings\" , \"delimiter\" : \";\" , \"namespace\" : \"Helpers\" , \"rootNamespace\" : null , \"properties\" : [ // Property Definitions ] } ] } } Note If we do not provide any of the values shown above they will automatically default as shown. Only the properties are required. Property Configuration \u00b6 The Mobile.BuildTools 2.0 added support for every primitive datatype, along with DateTime, DateTimeOffset, Uri, & Guid. Additionally you now have the ability to easily specify that a value should be an array. Note that this only generates arrays, you cannot specify other types such as List or Collection . { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"projectSecrets\" : { \"AwesomeApp\" : [ { \"properties\" : [ { \"name\" : \"MyProperty\" , \"type\" : \"String\" }, { \"name\" : \"MyProperty2\" , \"type\" : \"Int\" }, { \"name\" : \"MyProperty3\" , \"type\" : \"String\" , \"array\" : true } ] } ] } } Providing a Default Value \u00b6 There are a lot of values which either may not be sensitive or a default value would be safe to have in source control. We'll look at two scenarios here. Default value for App Center App Id \u00b6 It's pretty common for people using the Mobile.BuildTools to inject values such as the App Center App Id to be able to initialize the App Center SDK. It's also pretty common that you may not want to provide a value for local development. The Mobile.BuildTools makes this easy by understanding the reserved values of null and default . It doesn't matter which one you use, the Mobile.BuildTools will actually generate the code using the default keyword as this is safe across all data types, nullable, and non-nullable alike. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"appSettings\" : { \"AwesomeApp\" : [ { \"properties\" : [ { \"name\" : \"AppCenterAppId\" , \"type\" : \"String\" , \"defaultValue\" : \"null\" } ] } ] } } User specified Default value \u00b6 Other times we may have non-sensitive values that we need to configure defaults for. In the following scenario we may be setting up UDP logging with a Syslog Server. We know that the default port for UDP Syslog Servers is port 514. This value can simply be placed as { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"appSettings\" : { \"AwesomeApp\" : [ { \"properties\" : [ { \"name\" : \"SyslogServerPort\" , \"type\" : \"Int\" , \"defaultValue\" : \"514\" } ] } ] } }","title":"Configuration"},{"location":"config/appsettings/configuration/#ci-platform-issues","text":"A common problem with some build platforms such as Azure DevOps Windows Agents is that they cast all variables with ToUpper. This means that if you added MyVariable , what the Mobile.BuildTools would actually find was MYVARIABLE . With 1.x we had no way to convert this back to MyVariable for the source generation. This naturally caused a lot of problems. To solve this issue the Mobile.BuildTools now provides a configuration file that describes the projects and classes that it should generate.","title":"CI Platform Issues"},{"location":"config/appsettings/configuration/#configuring-the-buildtoolsjson","text":"The Mobile.BuildTools 2.0 configuration gives us a lot of flexibility as we can define 1 or MORE classes that should be generated automatically at build. Additionally since we can describe the class in json, we can specify exactly the data type should be rather than relying on the Mobile.BuildTools to make an educated guess. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"appSettings\" : { \"AwesomeApp\" : [ { // Your configuration here } ] } }","title":"Configuring the buildtools.json"},{"location":"config/appsettings/configuration/#class-configuration","text":"Within the Project we can now provide any configuration values we need to either override or explicitly provide that will control how the class will be generated. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"projectSecrets\" : { \"AwesomeApp\" : [ { \"accessibility\" : \"Internal\" , \"className\" : \"AppSettings\" , \"delimiter\" : \";\" , \"namespace\" : \"Helpers\" , \"rootNamespace\" : null , \"properties\" : [ // Property Definitions ] } ] } } Note If we do not provide any of the values shown above they will automatically default as shown. Only the properties are required.","title":"Class Configuration"},{"location":"config/appsettings/configuration/#property-configuration","text":"The Mobile.BuildTools 2.0 added support for every primitive datatype, along with DateTime, DateTimeOffset, Uri, & Guid. Additionally you now have the ability to easily specify that a value should be an array. Note that this only generates arrays, you cannot specify other types such as List or Collection . { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"projectSecrets\" : { \"AwesomeApp\" : [ { \"properties\" : [ { \"name\" : \"MyProperty\" , \"type\" : \"String\" }, { \"name\" : \"MyProperty2\" , \"type\" : \"Int\" }, { \"name\" : \"MyProperty3\" , \"type\" : \"String\" , \"array\" : true } ] } ] } }","title":"Property Configuration"},{"location":"config/appsettings/configuration/#providing-a-default-value","text":"There are a lot of values which either may not be sensitive or a default value would be safe to have in source control. We'll look at two scenarios here.","title":"Providing a Default Value"},{"location":"config/appsettings/configuration/#default-value-for-app-center-app-id","text":"It's pretty common for people using the Mobile.BuildTools to inject values such as the App Center App Id to be able to initialize the App Center SDK. It's also pretty common that you may not want to provide a value for local development. The Mobile.BuildTools makes this easy by understanding the reserved values of null and default . It doesn't matter which one you use, the Mobile.BuildTools will actually generate the code using the default keyword as this is safe across all data types, nullable, and non-nullable alike. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"appSettings\" : { \"AwesomeApp\" : [ { \"properties\" : [ { \"name\" : \"AppCenterAppId\" , \"type\" : \"String\" , \"defaultValue\" : \"null\" } ] } ] } }","title":"Default value for App Center App Id"},{"location":"config/appsettings/configuration/#user-specified-default-value","text":"Other times we may have non-sensitive values that we need to configure defaults for. In the following scenario we may be setting up UDP logging with a Syslog Server. We know that the default port for UDP Syslog Servers is port 514. This value can simply be placed as { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"appSettings\" : { \"AwesomeApp\" : [ { \"properties\" : [ { \"name\" : \"SyslogServerPort\" , \"type\" : \"Int\" , \"defaultValue\" : \"514\" } ] } ] } }","title":"User specified Default value"},{"location":"config/appsettings/faq/","text":"Q. I'm using a shared project with my Uno app, each app obviously has a different namespace. How can I get the generated class to use a specific root namespace? A. When configuring the AppSettings there are 2 namespace fields. You will need to set the rootNamespace . This will override the RootNamespace of the compiling project. Q. How can change the default namespace of the generated class to be in the root namespace of my project? A. Simply provide a value of . for the namespace property Q. What is the delimiter used for? A. Json objects are effectively a dictionary which cannot have repeated keys, similarly Environment Variables operate the same way. As a result things which are ultimately lists such as the PATH Environment property utilize a delimiter such as ; to separate the items in the list. By default the Mobile.BuildTools will use the semi-colon, though you can use any character or string you want. Any variables you've defined as arrays will use that delimiter to split the string into an array of whatever your datatype is. Q. Is there a way to get the generated class to use a List instead of an Array? A. No, this is a limitation of the API. If this is an issue for you please open an issue and explain your use case.","title":"F.A.Q."},{"location":"continuous-integration/platforms/","text":"Build Platforms \u00b6 Because the Mobile.BuildTools is a collection of MSBuild Targets, it works absolutely everywhere that MSBuild is available and building your project. It doesn't matter if you use Cake, or CLI scripts, or which CI platform you use. In general all of the common CI Platforms that Xamarin Developers might use are covered this includes: App Center Azure DevOps Appveyor Jenkins","title":"Platforms"},{"location":"continuous-integration/platforms/#build-platforms","text":"Because the Mobile.BuildTools is a collection of MSBuild Targets, it works absolutely everywhere that MSBuild is available and building your project. It doesn't matter if you use Cake, or CLI scripts, or which CI platform you use. In general all of the common CI Platforms that Xamarin Developers might use are covered this includes: App Center Azure DevOps Appveyor Jenkins","title":"Build Platforms"},{"location":"continuous-integration/setup/","text":"Continuous Integration Setup \u00b6 Obviously if we checked in a json file with our secrets it would negate the entire point of trying to secure our code base. The Build Tools include a Build Host Secrets task that executes prior to the Secrets Generation. This task will execute when the secrets json file does not exist in an attempt to generate the missing json file. This is designed to handle secrets across multiple projects. By default we assume you have a single shared project such as a .NET Standard library, and one or more platform projects like iOS, Android, UWP, macOS, & Tizen. To override the secrets prefix for any project you simply need to provide a value for BuildHostSecretPrefix Platform Secrets Prefix Android DroidSecret_ iOS iOSSecret_ UWP UWPSecret_ macOS MacSecret_ Tizen TizenSecret_ Default BuildTools_","title":"Setup"},{"location":"continuous-integration/setup/#continuous-integration-setup","text":"Obviously if we checked in a json file with our secrets it would negate the entire point of trying to secure our code base. The Build Tools include a Build Host Secrets task that executes prior to the Secrets Generation. This task will execute when the secrets json file does not exist in an attempt to generate the missing json file. This is designed to handle secrets across multiple projects. By default we assume you have a single shared project such as a .NET Standard library, and one or more platform projects like iOS, Android, UWP, macOS, & Tizen. To override the secrets prefix for any project you simply need to provide a value for BuildHostSecretPrefix Platform Secrets Prefix Android DroidSecret_ iOS iOSSecret_ UWP UWPSecret_ macOS MacSecret_ Tizen TizenSecret_ Default BuildTools_","title":"Continuous Integration Setup"},{"location":"google/","text":"Google Firebase is an incredibly popular solution for app analytics and cross platform push notifications. Unfortunately we see a lot of developers following poor programming practices including the google-services.json and GoogleService-Info.plist in source control. The Mobile.BuildTools is all about empowering you to follow best practices while developing your mobile apps. To start be sure to add these files to your .gitignore that way the file isn't accidentally checked into source control while you use it for local development. The Mobile.BuildTools is able to bring these resources in at build time using your favorite CI Build service. To get started you'll want to come up with a variable name and set this in your buildtools.json like the following: { \"google\" : { \"servicesJson\" : \"GoogleServicesJson\" , \"infoPlist\" : \"GoogleServicesInfoPlist\" } } If the variable exists locally or on your CI Server, the Mobile.BuildTools will automatically look it up and determine if it is a file path. If it is it will add the appropriate include for iOS/Android. Otherwise it will take the contents of the variable and add the file to the Intermediate Output Directory (the obj folder) during the build, and it will again add the appropriate platform include. Note Due to some build agents, such as all Windows agents on Azure DevOps, performing a ToUpper on all environment variable names, the Mobile.BuildTools will do a Case insensitive lookup to match the variable name.","title":"Google Firebase"},{"location":"images/","text":"Image Asset Generation \u00b6 It takes about 5 minutes as a Mobile developer until you realize that Mobile apps have a lot of image assets. If you're a Cross Platform developer you realize that with your doubled reach comes a doubling of the amount of image assets you need to track. One of the premiere features of the Mobile.BuildTools in version 2 is the ability to handle custom asset generation. We do this by only tracking or letting you worry about the Full Resolution image assets that you want as part of your app. Important It is extremely important to note that the Image Processing features listed here are largely WIP guidance on how these features are intended to work. As Image Processing is still very much WIP, not everything listed here may currently be functioning as expected. Adding Image Search Directories \u00b6 The Mobile.BuildTools allows you to bring in images within one or more directories in 3 different ways: Directories that should be searched for all builds { \"images\" : { \"directories\" : [ \"Images\" ] } } Directories that should conditionally be searched. See Conditional Directories for more information. { \"images\" : { \"conditionalDirectories\" : { \"someCondition\" : [ \"AnotherDirectory\" ] } } } MSBuild Configured Directories typically used in CI which can optionally override your json configuration. See the Build Customization topic for more information. Warning The Mobile.BuildTools will only evaluate images in the top level of the specified directories. Images in subdirectories will be ignored unless otherwise specified as a search directory or conditional directory. Conditional Directories \u00b6 Conditional Directories supercharges your ability deliver customized images for your apps. The Conditional Directories help us to get a better handle on what image assets we want to include either for a specified Target Platform or Build Configuration. Supported Conditions \u00b6 Platform Conditions A powerful feature of the Mobile.BuildTools is the ability to customize by Build Platform. This allows to to use the office Target Framework Moniker (TFM) or the more friendly platform name like the following. Xamarin.iOS iOS MonoAndroid Android Build Configurations Any Build Configuration you have! Optionally negate a Condition like !Debug { \"images\" : { \"directories\" : [ \"Images\" , \"Images\\\\Shared\" ], \"conditionalDirectories\" : { \"MonoAndroid\" : [ \"Images\\\\Android\" ], \"Xamarin.iOS\" : [ \"Images\\\\iOS\" ], \"Debug\" : [ \"Images\\\\Debug\" ], \"!Store\" : [ \"Images\\\\NotProduction\" ], \"Store\" : [ \"Images\\\\Production\" ] } } } Sample Outputs \u00b6 Using Conditional Directories along with the ability to watermark images (see Configuring Images topic) you can easily transform images. For this let's say that we have two watermark images that we want to use on one or more of the images that will be used in our app. Let's next say that we have two images we want to test this on like the following: Important You may have noticed from looking at these images that all of the images are different resolutions. The Mobile.BuildTools is smart enough to understand that we want to scale your watermark and your input image to share the same canvas size. We will then generate the appropriate output size based on what your needs are. Limitations \u00b6 Keep in mind that we do require that each image have a sibling json configuration file. This means that if your image is at the path: Images\\foo.png , then we would expect a configuration at Images\\foo.json , even if that file is an empty JSON file. When using Conditional Directories it is very much possible that you would have more than one json configuration file for a single image. The Mobile.BuildTools will ignore the sibling configuration any time a second json configuration file is found in another directory. Warning While the Mobile.BuildTools can handle locating 2 json configurations during a build where one of them is a sibling of the image, the Mobile.BuildTools cannot handle scenarios where you it locates more than one json configuration that is not a sibling of the image as we would not know which one is the proper one to use. Supported Platforms \u00b6 Not all platforms are supported. For more information see the grid below: Platform Status Android Supported iOS Supported macOS Supported * tvOS Supported * Tizen Not Supported - See issue #101 UWP Not Supported - See issue #100 Blazor Not Planned Web Assembly Not Planned * Platform is theoretically supported as there should be no difference from iOS, however this has not been directly tested.","title":"Getting Started"},{"location":"images/#image-asset-generation","text":"It takes about 5 minutes as a Mobile developer until you realize that Mobile apps have a lot of image assets. If you're a Cross Platform developer you realize that with your doubled reach comes a doubling of the amount of image assets you need to track. One of the premiere features of the Mobile.BuildTools in version 2 is the ability to handle custom asset generation. We do this by only tracking or letting you worry about the Full Resolution image assets that you want as part of your app. Important It is extremely important to note that the Image Processing features listed here are largely WIP guidance on how these features are intended to work. As Image Processing is still very much WIP, not everything listed here may currently be functioning as expected.","title":"Image Asset Generation"},{"location":"images/#adding-image-search-directories","text":"The Mobile.BuildTools allows you to bring in images within one or more directories in 3 different ways: Directories that should be searched for all builds { \"images\" : { \"directories\" : [ \"Images\" ] } } Directories that should conditionally be searched. See Conditional Directories for more information. { \"images\" : { \"conditionalDirectories\" : { \"someCondition\" : [ \"AnotherDirectory\" ] } } } MSBuild Configured Directories typically used in CI which can optionally override your json configuration. See the Build Customization topic for more information. Warning The Mobile.BuildTools will only evaluate images in the top level of the specified directories. Images in subdirectories will be ignored unless otherwise specified as a search directory or conditional directory.","title":"Adding Image Search Directories"},{"location":"images/#conditional-directories","text":"Conditional Directories supercharges your ability deliver customized images for your apps. The Conditional Directories help us to get a better handle on what image assets we want to include either for a specified Target Platform or Build Configuration.","title":"Conditional Directories"},{"location":"images/#supported-conditions","text":"Platform Conditions A powerful feature of the Mobile.BuildTools is the ability to customize by Build Platform. This allows to to use the office Target Framework Moniker (TFM) or the more friendly platform name like the following. Xamarin.iOS iOS MonoAndroid Android Build Configurations Any Build Configuration you have! Optionally negate a Condition like !Debug { \"images\" : { \"directories\" : [ \"Images\" , \"Images\\\\Shared\" ], \"conditionalDirectories\" : { \"MonoAndroid\" : [ \"Images\\\\Android\" ], \"Xamarin.iOS\" : [ \"Images\\\\iOS\" ], \"Debug\" : [ \"Images\\\\Debug\" ], \"!Store\" : [ \"Images\\\\NotProduction\" ], \"Store\" : [ \"Images\\\\Production\" ] } } }","title":"Supported Conditions"},{"location":"images/#sample-outputs","text":"Using Conditional Directories along with the ability to watermark images (see Configuring Images topic) you can easily transform images. For this let's say that we have two watermark images that we want to use on one or more of the images that will be used in our app. Let's next say that we have two images we want to test this on like the following: Important You may have noticed from looking at these images that all of the images are different resolutions. The Mobile.BuildTools is smart enough to understand that we want to scale your watermark and your input image to share the same canvas size. We will then generate the appropriate output size based on what your needs are.","title":"Sample Outputs"},{"location":"images/#limitations","text":"Keep in mind that we do require that each image have a sibling json configuration file. This means that if your image is at the path: Images\\foo.png , then we would expect a configuration at Images\\foo.json , even if that file is an empty JSON file. When using Conditional Directories it is very much possible that you would have more than one json configuration file for a single image. The Mobile.BuildTools will ignore the sibling configuration any time a second json configuration file is found in another directory. Warning While the Mobile.BuildTools can handle locating 2 json configurations during a build where one of them is a sibling of the image, the Mobile.BuildTools cannot handle scenarios where you it locates more than one json configuration that is not a sibling of the image as we would not know which one is the proper one to use.","title":"Limitations"},{"location":"images/#supported-platforms","text":"Not all platforms are supported. For more information see the grid below: Platform Status Android Supported iOS Supported macOS Supported * tvOS Supported * Tizen Not Supported - See issue #101 UWP Not Supported - See issue #100 Blazor Not Planned Web Assembly Not Planned * Platform is theoretically supported as there should be no difference from iOS, however this has not been directly tested.","title":"Supported Platforms"},{"location":"images/build-customization/","text":"The image processing feature of the Mobile.BuildTools has always been built with the intention of making white labeling apps or customizing resources like app icons based on build environment easier. Because of this, in addition to configuring this feature with the buildtools.json, we also support overriding your default configuration at build using more conventional MSBuild properties. Customizing the Search Paths \u00b6 In order to customize the search paths at build you should set the Property BuildToolsImageSearchPath . This property can contain multiple paths as long as the paths can be split with a semi-colon ; . Setting the property could be as simple as the following: <PropertyGroup> <BuildToolsImageSearchPath> $(SolutionDir)\\Images\\MoreImages;$(SolutionDir)\\Images\\AwesomeImages </BuildToolsImageSearchPath> </PropertyGroup> Overriding the Json Configuration \u00b6 The Image Processing feature of the Mobile.BuildTools allows you to completely override your JSON configuration at build by specifying an additional property BuildToolsIgnoreDefaultSearchPath . By setting this property to true in the presence of any build defined search paths, we will ignore all paths including the conditional paths specified in the buildtools.json. Putting this together \u00b6 To understand how we might use this in a DevOps environment we'll look at some YAML to see how this would look with Azure Pipelines: - task : XamariniOS@2 displayName : 'Build Xamarin.iOS solution' inputs : solutionFile : 'src/AwesomeApp.iOS/AwesomeApp.iOS.csproj' configuration : ${{ parameters.buildConfiguration }} packageApp : true runNuGetRestore : true args : '/p:BuildToolsImageSearchPath= '' $(ClientImages) '' /p:BuildToolsIgnoreDefaultSearchPath=true' env : Secret_SampleString : 'Sample String' Secret_SampleInt : '1' Secret_SampleDouble : '2.1' Secret_SampleBool : 'true'","title":"Build Customization"},{"location":"images/build-customization/#customizing-the-search-paths","text":"In order to customize the search paths at build you should set the Property BuildToolsImageSearchPath . This property can contain multiple paths as long as the paths can be split with a semi-colon ; . Setting the property could be as simple as the following: <PropertyGroup> <BuildToolsImageSearchPath> $(SolutionDir)\\Images\\MoreImages;$(SolutionDir)\\Images\\AwesomeImages </BuildToolsImageSearchPath> </PropertyGroup>","title":"Customizing the Search Paths"},{"location":"images/build-customization/#overriding-the-json-configuration","text":"The Image Processing feature of the Mobile.BuildTools allows you to completely override your JSON configuration at build by specifying an additional property BuildToolsIgnoreDefaultSearchPath . By setting this property to true in the presence of any build defined search paths, we will ignore all paths including the conditional paths specified in the buildtools.json.","title":"Overriding the Json Configuration"},{"location":"images/build-customization/#putting-this-together","text":"To understand how we might use this in a DevOps environment we'll look at some YAML to see how this would look with Azure Pipelines: - task : XamariniOS@2 displayName : 'Build Xamarin.iOS solution' inputs : solutionFile : 'src/AwesomeApp.iOS/AwesomeApp.iOS.csproj' configuration : ${{ parameters.buildConfiguration }} packageApp : true runNuGetRestore : true args : '/p:BuildToolsImageSearchPath= '' $(ClientImages) '' /p:BuildToolsIgnoreDefaultSearchPath=true' env : Secret_SampleString : 'Sample String' Secret_SampleInt : '1' Secret_SampleDouble : '2.1' Secret_SampleBool : 'true'","title":"Putting this together"},{"location":"images/built-in-templates/","text":"When using the built in drawing API in the Mobile.BuildTools, we will draw one a custom banner and text in one of 6 layouts. Top Left Top Top Right Bottom Left Bottom Bottom Right What can you edit? Use your specified text Use any system installed font Use a custom font from a specified font file Specify the Text Color Specify One or More Colors for the Banner to get your preferred style (solid or gradient)","title":"Built In Templates"},{"location":"images/configuring-images/","text":"The first time the Mobile.BuildTools encounters an image it will automatically generate a default image configuration file along side of the image. This file is what allows you to customize and further refine the image that you want. A configuration file may reside a conditional search directory. The Mobile.BuildTools will opt to use a configuration that is not in the same file directory as the image resource any time that a duplication is found. Warning Keep in mind that we only ever support a scenario where you have a single configuration in a directory other than the original image. In the event that two or more configurations are found for the same image in directories other than the directory where the image is located the Mobile.BuildTools will throw an exception causing a Build Error. Note If you have an image name that contains white space such as foo bar.png , the Mobile.BuildTools will sanitize the file name replace any contiguous white space characters with a single - . This normalization is required by Android and will mean that you will need to reference the image as foo-bar.png . Configuring Images \u00b6 The Schema for configuring images is rather simple by design. We allow you to specify a watermark file name, a name, a scale and an optional ignore. To start let's consider that we have an image named Mobile-BuildTools.png . We know that we cannot get away with this file name on all platforms so we want to rename the generated image. { \"$schema\" : \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\" , \"name\" : \"mobile_buildtools\" } The above sample would allow us to have a resource named mobile_buildtools when we refer to this from our Xamarin code. Platform Specific Configurations \u00b6 There is a common schema for image configuration which includes the following properties: { \"$schema\" : \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\" , \"name\" : \"someName\" , \"scale\" : 0.875 , \"backgroundColor\" : \"#ffffff\" , \"ignore\" : false , } This schema is available generally for each image and can be used to further tweak or customize for the platform. As an example let's consider that we want the Mobile-BuildTools.png to be used as the app icon. We will want to use the App Icon Set on iOS named AppIcon and we'll want to use the image name icon on Android. To accomplish this our configuration would look like: { \"$schema\" : \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\" , \"android\" : { \"name\" : \"icon\" }, \"apple\" : { \"name\" : \"AppIcon\" } } Let's now consider a few facts about our icon that would be quite common, particularly when sharing the same resource between iOS and Android for the App Icon. We want the Android resource to be in the mipmap folder rather the drawable folders Our full size image is much larger than the full size icon should be for Android Our image has a transparent background which will need to be adjusted on iOS Given these additional criteria we would want to update our configuration as follows: { \"$schema\" : \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\" , \"android\" : { \"name\" : \"icon\" , \"resourceType\" : \"Mipmap\" , \"scale\" : 0.375 }, \"apple\" : { \"name\" : \"AppIcon\" , \"backgroundColor\" : \"#fc7e00\" } } Note Android specific configuration defines an additional property for the Resource Type. By default this is set to Drawable. You can however change this in your image configuration for mipmap resources. Watermarking Images \u00b6 One of the great things that the Mobile.BuildTools supports is watermarking images at build. This is a very powerful feature as shown below. To configure images for Watermarking there are a few simple steps that you will need to take. Let's first make a couple of assumptions. You have your base resources in the path Images This includes an image asset called icon.png You have a subfolder called Images\\Debug Inside of this directory you have a watermark file called beta-version.png In order to set this up our buildtools.json might look like this: { \"images\" : { \"directories\" : [ \"Images\" ], \"conditionalDirectories\" : { \"Debug\" : [ \"Images\\\\Debug\" ] } } } icon.png beta-version.png output: icon.png When the Mobile.BuildTools runs and the Image collector locates an image, it will automatically generate a default JSON configuration file. The configuration file must have the same name as the image without the file extension. As a result after the first run our output image will look exactly the same as our input image only resized, and we would also have an asset added for the beta-version.png although this was not what we had wanted. The file system will also now contain the new files Images\\icon.json & Images\\Debug\\beta-version.json . You will not need to do anything to the Images\\icon.json file, however you will want to copy this to Images\\Debug directory. Next you'll want to open a text editor such as Visual Studio Code which will automatically pick up the schema referenced in the generated file and give you intellisense as you work on the file. We'll update the following two files as follows: Images\\Debug\\beta-version.json { \"$schema\" : \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\" , \"ignore\" : true } Images\\Debug\\icon.json { \"$schema\" : \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\" , \"watermark\" : { \"sourceFile\" : \"beta-version\" } } Warning When using Conditional Directories to modify images with watermarks be sure that there is never more than one conditional configuration included. Doing so will result in a build error as the Mobile.BuildTools has no way of know which conditional configuration to use. With our updated configurations we can now rebuild and the Mobile.BuildTools will generally ignore the beta-version.png as an asset of it's own while it will apply the beta-version.png as an overlay to our icon during our debug builds. Drawn Watermarks \u00b6 Just like mentioned above we can provide a configuration file for our image in a conditional directory to use the full watermarking power without having to have any specific image resource for our overlay. The Mobile.BuildTools provides a built in powerful drawing API with 6 different layout options and complete customization of the text, font and colors used. { \"watermark\" : { \"colors\" : [ \"Purple\" , \"#008888\" ], \"text\" : \"Dev\" , \"fontFamily\" : \"Times New Roman\" , \"opacity\" : 0.85 } }","title":"Configuring Images"},{"location":"images/configuring-images/#configuring-images","text":"The Schema for configuring images is rather simple by design. We allow you to specify a watermark file name, a name, a scale and an optional ignore. To start let's consider that we have an image named Mobile-BuildTools.png . We know that we cannot get away with this file name on all platforms so we want to rename the generated image. { \"$schema\" : \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\" , \"name\" : \"mobile_buildtools\" } The above sample would allow us to have a resource named mobile_buildtools when we refer to this from our Xamarin code.","title":"Configuring Images"},{"location":"images/configuring-images/#platform-specific-configurations","text":"There is a common schema for image configuration which includes the following properties: { \"$schema\" : \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\" , \"name\" : \"someName\" , \"scale\" : 0.875 , \"backgroundColor\" : \"#ffffff\" , \"ignore\" : false , } This schema is available generally for each image and can be used to further tweak or customize for the platform. As an example let's consider that we want the Mobile-BuildTools.png to be used as the app icon. We will want to use the App Icon Set on iOS named AppIcon and we'll want to use the image name icon on Android. To accomplish this our configuration would look like: { \"$schema\" : \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\" , \"android\" : { \"name\" : \"icon\" }, \"apple\" : { \"name\" : \"AppIcon\" } } Let's now consider a few facts about our icon that would be quite common, particularly when sharing the same resource between iOS and Android for the App Icon. We want the Android resource to be in the mipmap folder rather the drawable folders Our full size image is much larger than the full size icon should be for Android Our image has a transparent background which will need to be adjusted on iOS Given these additional criteria we would want to update our configuration as follows: { \"$schema\" : \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\" , \"android\" : { \"name\" : \"icon\" , \"resourceType\" : \"Mipmap\" , \"scale\" : 0.375 }, \"apple\" : { \"name\" : \"AppIcon\" , \"backgroundColor\" : \"#fc7e00\" } } Note Android specific configuration defines an additional property for the Resource Type. By default this is set to Drawable. You can however change this in your image configuration for mipmap resources.","title":"Platform Specific Configurations"},{"location":"images/configuring-images/#watermarking-images","text":"One of the great things that the Mobile.BuildTools supports is watermarking images at build. This is a very powerful feature as shown below. To configure images for Watermarking there are a few simple steps that you will need to take. Let's first make a couple of assumptions. You have your base resources in the path Images This includes an image asset called icon.png You have a subfolder called Images\\Debug Inside of this directory you have a watermark file called beta-version.png In order to set this up our buildtools.json might look like this: { \"images\" : { \"directories\" : [ \"Images\" ], \"conditionalDirectories\" : { \"Debug\" : [ \"Images\\\\Debug\" ] } } } icon.png beta-version.png output: icon.png When the Mobile.BuildTools runs and the Image collector locates an image, it will automatically generate a default JSON configuration file. The configuration file must have the same name as the image without the file extension. As a result after the first run our output image will look exactly the same as our input image only resized, and we would also have an asset added for the beta-version.png although this was not what we had wanted. The file system will also now contain the new files Images\\icon.json & Images\\Debug\\beta-version.json . You will not need to do anything to the Images\\icon.json file, however you will want to copy this to Images\\Debug directory. Next you'll want to open a text editor such as Visual Studio Code which will automatically pick up the schema referenced in the generated file and give you intellisense as you work on the file. We'll update the following two files as follows: Images\\Debug\\beta-version.json { \"$schema\" : \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\" , \"ignore\" : true } Images\\Debug\\icon.json { \"$schema\" : \"http://mobilebuildtools.com/schemas/v2/resourceDefinition.schema.json\" , \"watermark\" : { \"sourceFile\" : \"beta-version\" } } Warning When using Conditional Directories to modify images with watermarks be sure that there is never more than one conditional configuration included. Doing so will result in a build error as the Mobile.BuildTools has no way of know which conditional configuration to use. With our updated configurations we can now rebuild and the Mobile.BuildTools will generally ignore the beta-version.png as an asset of it's own while it will apply the beta-version.png as an overlay to our icon during our debug builds.","title":"Watermarking Images"},{"location":"images/configuring-images/#drawn-watermarks","text":"Just like mentioned above we can provide a configuration file for our image in a conditional directory to use the full watermarking power without having to have any specific image resource for our overlay. The Mobile.BuildTools provides a built in powerful drawing API with 6 different layout options and complete customization of the text, font and colors used. { \"watermark\" : { \"colors\" : [ \"Purple\" , \"#008888\" ], \"text\" : \"Dev\" , \"fontFamily\" : \"Times New Roman\" , \"opacity\" : 0.85 } }","title":"Drawn Watermarks"},{"location":"manifests/","text":"App Manifests \u00b6 There are many times in which you may need to parameterize an AndroidManifest.xml or Info.plist. One such example would be when using the MSAL library for Azure Active Directory / Azure Active Directory B2C user authentication in which you must create a custom url scheme like: <key> CFBundleURLTypes </key> <array> <dict> <key> CFBundleTypeRole </key> <string> Editor </string> <key> CFBundleURLName </key> <string> com.avantipoint.awesomeapp </string> <key> CFBundleURLSchemes </key> <array> <string> msal$AzureADClientId$ </string> </array> </dict> </array> We can now leave our Info.plist or AndroidManifest.xml checked into source control and in place in our project. The Mobile.BuildTools will intelligently replace any tokenized values like the one above during the build. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"manifests\" : { \"token\" : \"$$\" , \"variablePrefix\" : \"Manifest_\" , \"missingTokensAsErrors\" : false , \"disable\" : false }, Note If no environment variable can be found matching Manifest_ as the prefix is defined, the Mobile.BuildTools will next search for a variable name matching the token name which would be AzureADClientId in the sample above. It will also try to do all matches case insensitive due to the issue with some build agents running ToUpper() on all variable names. Info In order to work with the tokenized manifest locally without having to update your Environment Variables on your developer machine, you can simply drop in a manifest.json in the Project root with the Key/Value pairs for the Mobile.BuildTools to use. If using this file, be sure to add it to the .gitignore so as to not accidentally check it into source control. Setting the Variables \u00b6 The Mobile.BuildTools attempts to locate the values for your Manifest tokens through several sources. In the event that a variable key is duplicated, the Mobile.BuildTools has a precedence that the last one in wins. Variables are loaded from the following sources: buildtools.json Environment Defaults buildtools.json Environment Configuration (i.e. Debug, Release) System Environment Recursively load legacy secrets.json from the Project directory to the Solution directory Recursively load appsettings.json from the Project directory to the Solution directory","title":"Tokenized Manifests"},{"location":"manifests/#app-manifests","text":"There are many times in which you may need to parameterize an AndroidManifest.xml or Info.plist. One such example would be when using the MSAL library for Azure Active Directory / Azure Active Directory B2C user authentication in which you must create a custom url scheme like: <key> CFBundleURLTypes </key> <array> <dict> <key> CFBundleTypeRole </key> <string> Editor </string> <key> CFBundleURLName </key> <string> com.avantipoint.awesomeapp </string> <key> CFBundleURLSchemes </key> <array> <string> msal$AzureADClientId$ </string> </array> </dict> </array> We can now leave our Info.plist or AndroidManifest.xml checked into source control and in place in our project. The Mobile.BuildTools will intelligently replace any tokenized values like the one above during the build. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"manifests\" : { \"token\" : \"$$\" , \"variablePrefix\" : \"Manifest_\" , \"missingTokensAsErrors\" : false , \"disable\" : false }, Note If no environment variable can be found matching Manifest_ as the prefix is defined, the Mobile.BuildTools will next search for a variable name matching the token name which would be AzureADClientId in the sample above. It will also try to do all matches case insensitive due to the issue with some build agents running ToUpper() on all variable names. Info In order to work with the tokenized manifest locally without having to update your Environment Variables on your developer machine, you can simply drop in a manifest.json in the Project root with the Key/Value pairs for the Mobile.BuildTools to use. If using this file, be sure to add it to the .gitignore so as to not accidentally check it into source control.","title":"App Manifests"},{"location":"manifests/#setting-the-variables","text":"The Mobile.BuildTools attempts to locate the values for your Manifest tokens through several sources. In the event that a variable key is duplicated, the Mobile.BuildTools has a precedence that the last one in wins. Variables are loaded from the following sources: buildtools.json Environment Defaults buildtools.json Environment Configuration (i.e. Debug, Release) System Environment Recursively load legacy secrets.json from the Project directory to the Solution directory Recursively load appsettings.json from the Project directory to the Solution directory","title":"Setting the Variables"},{"location":"manifests/versioning/","text":"Build Versioning \u00b6 Build versioning can be extremely important for analytics and diagnostics. What's more is that Mobile development requires unique builds. No longer can you be lazy and ship apps for 15 years at Version 1.0.0.0. Ok technically all of your binaries in the application all will show that version, but the app itself must have a unique build number to allow you to upload to the App Store and Google Play. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"automaticVersioning\" : { \"behavior\" : \"PreferBuildNumber\" , \"environment\" : \"All\" , \"versionOffset\" : 0 , \"disable\" : false }, } Automatic Build Versioning supports the following Versioning Environments: Environment Description All Versioning will occur on every build. BuildHost Versioning will only occur if a *Supported Build Host is detected. Local Versioning will only occur if a *Supported Build Host is not detected. Automatic Build Versioning supports the following Behavior 's: Behavior Description Off Automatic Versioning is Disabled PreferBuildNumber When running on a *Supported Build Host it will use the Build Number, otherwise it will use the current timestamp Timestamp Automatic Versioning will use the timestamp for the build * Supported Build Hosts: AppCenter AppVeyor Azure DevOps Jenkins Info You might use the versionOffset when your CI Build Number and Build Number in the App Store or Google Play are not in sync. As an example, when shipping multiple APKs with the same build number Google Play may take build 123 and make it 100123, 200123, 300123, & 400123 respectively for each of the 4 APK's you have provided. This would mean when switching to AAB that you might need to offset by 400000 in order to get your new AAB build to show up in Google Play. Planned Enhancements \u00b6 Build Versioning is a brand new task that has been planned for a long time and sadly has taken a lot longer to get implemented than what was originally anticipated. Beginning with the push for 2.1 we will be looking at more advanced scenarios: Support scenarios where you may want to control a public display version like 1.0 but need a unique build id so that you can resubmit to the store if the App Store or Google Play reject your app during review. Support using GitVersioning. Git Versioning is a popular technique used by a lot of modern libraries including the Mobile.BuildTools. This occurs by evaluating the Git Height, and is generally controlled with a version.json in the root directory. You can look at the Mobile.BuildTools repo for an example of this using Nerdbank.GitVersioning.","title":"Build Versioning"},{"location":"manifests/versioning/#build-versioning","text":"Build versioning can be extremely important for analytics and diagnostics. What's more is that Mobile development requires unique builds. No longer can you be lazy and ship apps for 15 years at Version 1.0.0.0. Ok technically all of your binaries in the application all will show that version, but the app itself must have a unique build number to allow you to upload to the App Store and Google Play. { \"$schema\" : \"https://mobilebuildtools.com/schemas/v2/buildtools.schema.json\" , \"automaticVersioning\" : { \"behavior\" : \"PreferBuildNumber\" , \"environment\" : \"All\" , \"versionOffset\" : 0 , \"disable\" : false }, } Automatic Build Versioning supports the following Versioning Environments: Environment Description All Versioning will occur on every build. BuildHost Versioning will only occur if a *Supported Build Host is detected. Local Versioning will only occur if a *Supported Build Host is not detected. Automatic Build Versioning supports the following Behavior 's: Behavior Description Off Automatic Versioning is Disabled PreferBuildNumber When running on a *Supported Build Host it will use the Build Number, otherwise it will use the current timestamp Timestamp Automatic Versioning will use the timestamp for the build * Supported Build Hosts: AppCenter AppVeyor Azure DevOps Jenkins Info You might use the versionOffset when your CI Build Number and Build Number in the App Store or Google Play are not in sync. As an example, when shipping multiple APKs with the same build number Google Play may take build 123 and make it 100123, 200123, 300123, & 400123 respectively for each of the 4 APK's you have provided. This would mean when switching to AAB that you might need to offset by 400000 in order to get your new AAB build to show up in Google Play.","title":"Build Versioning"},{"location":"manifests/versioning/#planned-enhancements","text":"Build Versioning is a brand new task that has been planned for a long time and sadly has taken a lot longer to get implemented than what was originally anticipated. Beginning with the push for 2.1 we will be looking at more advanced scenarios: Support scenarios where you may want to control a public display version like 1.0 but need a unique build id so that you can resubmit to the store if the App Store or Google Play reject your app during review. Support using GitVersioning. Git Versioning is a popular technique used by a lot of modern libraries including the Mobile.BuildTools. This occurs by evaluating the Git Height, and is generally controlled with a version.json in the root directory. You can look at the Mobile.BuildTools repo for an example of this using Nerdbank.GitVersioning.","title":"Planned Enhancements"},{"location":"scss-to-css/","text":"SCSS to Xamarin.Forms CSS \u00b6 While CSS support in Xamarin.Forms has been a highly controversial topic in which you likely either love it or hate it, it has been my view that CSS support in Xamarin.Forms is the most revolutionary change to Styling XAML. CSS though is traditionally problematic on larger projects as it can quickly become hard to maintain, and error prone as it lacks reusability of common values which could include setting various properties or reusing the same color from one element to the next. With SCSS you gain the ability to break your stylesheets into logical reusable chunks and you gain the ability to define variables and functions for creating your styles. For those developers who want to start using CSS in their Xamarin.Forms application, the Mobile.BuildTools empowers you to leverage SCSS which is compiled into Xamarin.Forms compatible CSS at build. Valid Xamarin.Forms CSS \u00b6 Perhaps one of the most frustrating things about Xamarin.Forms CSS is that the spec is NOT compliant with standard CSS linting. Specifically Xamarin.Forms requires the ^ prefix when looking to have a style apply to any inheriting type which you may want to do for instance when styling a Page. ^ button { background-color : transparent ; } . primary ^ button { background-color : #78909c ; } The Mobile.BuildTools will post process your SCSS to generate valid CSS for Xamarin.Forms when using the selectors any or all . Valid SCSS used by the Mobile.BuildTools \u00b6 button : any { background-color : transparent ; } . primary button : all { background-color : #78909c ; } Getting Started \u00b6 To get started, simply add any scss format stylesheets you want to your project and make sure that the build action is set to None . The Mobile.BuildTools will automatically detect them and generate a CSS file for each non-partial (anything not starting with an underscore). For more information on how to get started with SCSS see the Getting Started Guide from LibSass. Note Xamarin.Forms does not support minimized files","title":"General Info"},{"location":"scss-to-css/#scss-to-xamarinforms-css","text":"While CSS support in Xamarin.Forms has been a highly controversial topic in which you likely either love it or hate it, it has been my view that CSS support in Xamarin.Forms is the most revolutionary change to Styling XAML. CSS though is traditionally problematic on larger projects as it can quickly become hard to maintain, and error prone as it lacks reusability of common values which could include setting various properties or reusing the same color from one element to the next. With SCSS you gain the ability to break your stylesheets into logical reusable chunks and you gain the ability to define variables and functions for creating your styles. For those developers who want to start using CSS in their Xamarin.Forms application, the Mobile.BuildTools empowers you to leverage SCSS which is compiled into Xamarin.Forms compatible CSS at build.","title":"SCSS to Xamarin.Forms CSS"},{"location":"scss-to-css/#valid-xamarinforms-css","text":"Perhaps one of the most frustrating things about Xamarin.Forms CSS is that the spec is NOT compliant with standard CSS linting. Specifically Xamarin.Forms requires the ^ prefix when looking to have a style apply to any inheriting type which you may want to do for instance when styling a Page. ^ button { background-color : transparent ; } . primary ^ button { background-color : #78909c ; } The Mobile.BuildTools will post process your SCSS to generate valid CSS for Xamarin.Forms when using the selectors any or all .","title":"Valid Xamarin.Forms CSS"},{"location":"scss-to-css/#valid-scss-used-by-the-mobilebuildtools","text":"button : any { background-color : transparent ; } . primary button : all { background-color : #78909c ; }","title":"Valid SCSS used by the Mobile.BuildTools"},{"location":"scss-to-css/#getting-started","text":"To get started, simply add any scss format stylesheets you want to your project and make sure that the build action is set to None . The Mobile.BuildTools will automatically detect them and generate a CSS file for each non-partial (anything not starting with an underscore). For more information on how to get started with SCSS see the Getting Started Guide from LibSass. Note Xamarin.Forms does not support minimized files","title":"Getting Started"},{"location":"scss-to-css/css-notes/","text":"Supported Selectors \u00b6 Selector Example Description .class .header Selects all elements with the StyleClass property containing 'header' #id #email Selects all elements with StyleId set to email. If StyleId is not set, fallback to x:Name. When using Xaml, always prefer x:Name over StyleId. * * Selects all elements element label Selects all elements of type Label (but not subclasses). Case irrelevant. ^base ^contentpage Selects all elements with ContentPage as base class, including ContentPage itself. Case irrelevant. This selector isn't present in the CSS specification, and only applies to XF. element,element label,button Selects all Buttons and all Labels element element stacklayout label Selects all Labels inside of a StackLayout element>element stacklayout>label Selects all Labels with StackLayout as a direct parent element+element label+entry Selects all Entries directly after a Label element~element label~entry Selects all Entries preceded by a Label Unsupported Selectors (for this version) \u00b6 [attribute] selectors @media or @supports selectors : or :: selectors Selector combinations \u00b6 Selectors can be combined without limitation, like in StackLayout > ContentView > label.email. But keep it sane ! Precedence \u00b6 Styles with matching selectors are all applied, on by one, in definition order. Styles defined on the item itself is always applied last. This is the expected behavior in most cases, even if doesn't 100% match common CSS implementations. Specificity, and specificity overrides ( !important ) are not supported. This is a known issue. Unsupported Common Properties \u00b6 all: initial layout properties (box, or grid). FlexLayout is coming, and it'll be CSS stylable, shorthand properties, like font , border Colors \u00b6 one of the 140 X11 color (https://en.wikipedia.org/wiki/X11_color_names), which happens to match CSS Colors, UWP predefined colors and XF Colors. Case insensitive HEX: #rgb , #argb , #rrggbb , #aarrggbb RGB: rgb(255,0,0) , rgb(100%,0%,0%) => values in range 0-255 or 0%-100% RGBA: rgba(255, 0, 0, 0.8) , rgba(100%, 0%, 0%, 0.8) => opacity is 0.0-1.0 HSL: hsl(120, 100%, 50%) => h is 0-360, s and l are 0%-100% HSLA: hsla(120, 100%, 50%, .8) => opacity is 0.0-1.0 Thickness \u00b6 One, two, three or four values, separated by white spaces. a single value indicates uniform thickness two values indicates (resp.) vertical and horizontal thickness three values indicates (resp.) top, horizontal (left and right) and bottom thickness when using four values, they are top, right, bottom, left IMPORTANT: This differs from Xaml thickness definitions, which are separated by commas ( , ) are in the form of uniform , horizontal , vertical or left , top , right , bottom NamedSize \u00b6 One of the following value, case insensitive. Exact meaning depends of the platform and the control default micro small medium large Initial \u00b6 initial is a valid value for all properties. It clears the value (resets to default) that was set from another Style. Additional remarks \u00b6 no inheritance supported, meaning no inherit value and that you can't set the font-size to a layout, and expect all the labels in that layout to inherit the value. The only exception is the direction property, which supports inherit , and that's the default value. element are matched by name, no support for xmlns","title":"Usage Notes"},{"location":"scss-to-css/css-notes/#supported-selectors","text":"Selector Example Description .class .header Selects all elements with the StyleClass property containing 'header' #id #email Selects all elements with StyleId set to email. If StyleId is not set, fallback to x:Name. When using Xaml, always prefer x:Name over StyleId. * * Selects all elements element label Selects all elements of type Label (but not subclasses). Case irrelevant. ^base ^contentpage Selects all elements with ContentPage as base class, including ContentPage itself. Case irrelevant. This selector isn't present in the CSS specification, and only applies to XF. element,element label,button Selects all Buttons and all Labels element element stacklayout label Selects all Labels inside of a StackLayout element>element stacklayout>label Selects all Labels with StackLayout as a direct parent element+element label+entry Selects all Entries directly after a Label element~element label~entry Selects all Entries preceded by a Label","title":"Supported Selectors"},{"location":"scss-to-css/css-notes/#unsupported-selectors-for-this-version","text":"[attribute] selectors @media or @supports selectors : or :: selectors","title":"Unsupported Selectors (for this version)"},{"location":"scss-to-css/css-notes/#selector-combinations","text":"Selectors can be combined without limitation, like in StackLayout > ContentView > label.email. But keep it sane !","title":"Selector combinations"},{"location":"scss-to-css/css-notes/#precedence","text":"Styles with matching selectors are all applied, on by one, in definition order. Styles defined on the item itself is always applied last. This is the expected behavior in most cases, even if doesn't 100% match common CSS implementations. Specificity, and specificity overrides ( !important ) are not supported. This is a known issue.","title":"Precedence"},{"location":"scss-to-css/css-notes/#unsupported-common-properties","text":"all: initial layout properties (box, or grid). FlexLayout is coming, and it'll be CSS stylable, shorthand properties, like font , border","title":"Unsupported Common Properties"},{"location":"scss-to-css/css-notes/#colors","text":"one of the 140 X11 color (https://en.wikipedia.org/wiki/X11_color_names), which happens to match CSS Colors, UWP predefined colors and XF Colors. Case insensitive HEX: #rgb , #argb , #rrggbb , #aarrggbb RGB: rgb(255,0,0) , rgb(100%,0%,0%) => values in range 0-255 or 0%-100% RGBA: rgba(255, 0, 0, 0.8) , rgba(100%, 0%, 0%, 0.8) => opacity is 0.0-1.0 HSL: hsl(120, 100%, 50%) => h is 0-360, s and l are 0%-100% HSLA: hsla(120, 100%, 50%, .8) => opacity is 0.0-1.0","title":"Colors"},{"location":"scss-to-css/css-notes/#thickness","text":"One, two, three or four values, separated by white spaces. a single value indicates uniform thickness two values indicates (resp.) vertical and horizontal thickness three values indicates (resp.) top, horizontal (left and right) and bottom thickness when using four values, they are top, right, bottom, left IMPORTANT: This differs from Xaml thickness definitions, which are separated by commas ( , ) are in the form of uniform , horizontal , vertical or left , top , right , bottom","title":"Thickness"},{"location":"scss-to-css/css-notes/#namedsize","text":"One of the following value, case insensitive. Exact meaning depends of the platform and the control default micro small medium large","title":"NamedSize"},{"location":"scss-to-css/css-notes/#initial","text":"initial is a valid value for all properties. It clears the value (resets to default) that was set from another Style.","title":"Initial"},{"location":"scss-to-css/css-notes/#additional-remarks","text":"no inheritance supported, meaning no inherit value and that you can't set the font-size to a layout, and expect all the labels in that layout to inherit the value. The only exception is the direction property, which supports inherit , and that's the default value. element are matched by name, no support for xmlns","title":"Additional remarks"},{"location":"scss-to-css/in-code/","text":"XAML (preferred) \u00b6 <ContentPage x:Class= \"...\" > <ContentPage.Resources> <StyleSheet Source= \"appresources/style.css\" /> </ContentPage.Resources> </ContentPage> the Source argument takes an Uri relative to the current xaml control, or relative to the application root if it starts with a / . The style.css has to be an EmbeddedResource. alternatively, you can inline your style in a CDATA Section <ContentPage x:Class= \"...\" > <ContentPage.Resources> <StyleSheet> <![CDATA[ ^contentpage { background-color: orange; padding: 20; } stacklayout > * { margin: 3; } ]]> </StyleSheet> </ContentPage.Resources> </ContentPage> do not abuse that second syntax. in C \u00b6 From an embedded resource: myPage . Resources . Add ( StyleSheet . FromAssemblyResource ( this . GetType (). Assembly , \"resource.id.of.the.css\" )); or from a TextReader: using ( var reader = new StringReader ( my_css_string )) myPage . Resources . Add ( StyleSheet . FromReader ( reader )); StyleSheet, XamlC and other potential optimizations \u00b6 At this time, CSS StyleSheets are parsed and evaluated at runtime. That aren't compiled. Every time a StyleSheet is used, it's reparsed again. If parsing time is an issue, enabling caching is trivial, but comes at memory cost.","title":"In Code"},{"location":"scss-to-css/in-code/#xaml-preferred","text":"<ContentPage x:Class= \"...\" > <ContentPage.Resources> <StyleSheet Source= \"appresources/style.css\" /> </ContentPage.Resources> </ContentPage> the Source argument takes an Uri relative to the current xaml control, or relative to the application root if it starts with a / . The style.css has to be an EmbeddedResource. alternatively, you can inline your style in a CDATA Section <ContentPage x:Class= \"...\" > <ContentPage.Resources> <StyleSheet> <![CDATA[ ^contentpage { background-color: orange; padding: 20; } stacklayout > * { margin: 3; } ]]> </StyleSheet> </ContentPage.Resources> </ContentPage> do not abuse that second syntax.","title":"XAML (preferred)"},{"location":"scss-to-css/in-code/#in-c","text":"From an embedded resource: myPage . Resources . Add ( StyleSheet . FromAssemblyResource ( this . GetType (). Assembly , \"resource.id.of.the.css\" )); or from a TextReader: using ( var reader = new StringReader ( my_css_string )) myPage . Resources . Add ( StyleSheet . FromReader ( reader ));","title":"in C"},{"location":"scss-to-css/in-code/#stylesheet-xamlc-and-other-potential-optimizations","text":"At this time, CSS StyleSheets are parsed and evaluated at runtime. That aren't compiled. Every time a StyleSheet is used, it's reparsed again. If parsing time is an issue, enabling caching is trivial, but comes at memory cost.","title":"StyleSheet, XamlC and other potential optimizations"},{"location":"scss-to-css/properties/","text":"Property Applies To Value Type / Info background-color VisualElement BackgroundColorProperty background-image Page BackgroundImageSourceProperty border-color IBorderElement BorderColorProperty border-radius ICornerElement CornerRadiusProperty border-radius Button CornerRadiusProperty border-radius Frame CornerRadiusProperty border-radius ImageButton CornerRadiusProperty border-width IBorderElement BorderWidthProperty color IColorElement ColorProperty, Inherited = true color ITextElement TextColorProperty, Inherited = true color ProgressBar ProgressBar.ProgressColorProperty color Switch OnColorProperty column-gap Grid ColumnSpacingProperty direction VisualElement FlowDirectionProperty, Inherited = true font-family IFontElement FontFamilyProperty, Inherited = true font-size IFontElement FontSizeProperty, Inherited = true font-style IFontElement FontAttributesProperty, Inherited = true height VisualElement HeightRequestProperty margin View View.MarginProperty margin-left View View.MarginLeftProperty margin-top View View.MarginTopProperty margin-right View View.MarginRightProperty margin-bottom View View.MarginBottomProperty max-lines Label Label.MaxLinesProperty min-height VisualElement MinimumHeightRequestProperty min-width VisualElement MinimumWidthRequestProperty opacity VisualElement OpacityProperty padding IPaddingElement PaddingProperty padding-left IPaddingElement PaddingLeftProperty, PropertyOwnerType = PaddingElement padding-top IPaddingElement PaddingTopProperty, PropertyOwnerType = PaddingElement padding-right IPaddingElement PaddingRightProperty, PropertyOwnerType = PaddingElement padding-bottom IPaddingElement PaddingBottomProperty, PropertyOwnerType = PaddingElement row-gap Grid RowSpacingProperty text-align ITextAlignmentElement HorizontalTextAlignmentProperty, Inherited = true text-decoration IDecorableTextElement DecorableTextElement.TextDecorationsProperty transform VisualElement TransformProperty transform-origin VisualElement TransformOriginProperty vertical-align ITextAlignmentElement VerticalTextAlignmentProperty visibility VisualElement IsVisibleProperty, Inherited = true width VisualElement WidthRequestProperty letter-spacing ITextElement CharacterSpacingProperty, Inherited = true line-height ILineHeightElement LineHeightProperty, Inherited = true FlexLayout \u00b6 Property Applies To Value Type / Info align-content FlexLayout AlignContentProperty align-items FlexLayout AlignItemsProperty align-self VisualElement AlignSelfProperty, PropertyOwnerType = FlexLayout flex-direction FlexLayout DirectionProperty flex-basis VisualElement BasisProperty, PropertyOwnerType = FlexLayout flex-grow VisualElement GrowProperty, PropertyOwnerType = FlexLayout flex-shrink VisualElement ShrinkProperty, PropertyOwnerType = FlexLayout flex-wrap VisualElement WrapProperty, PropertyOwnerType = FlexLayout justify-content FlexLayout JustifyContentProperty order VisualElement OrderProperty, PropertyOwnerType = FlexLayout position FlexLayout PositionProperty Xamarin.Forms Specific Properties \u00b6 Property Applies To Value Type / Info -xf-placeholder IPlaceholderElement PlaceholderProperty -xf-placeholder-color IPlaceholderElement PlaceholderColorProperty -xf-max-length InputView MaxLengthProperty -xf-bar-background-color IBarElement BarBackgroundColorProperty -xf-bar-text-color IBarElement BarTextColorProperty -xf-orientation ScrollView OrientationProperty -xf-horizontal-scroll-bar-visibility ScrollView HorizontalScrollBarVisibilityProperty -xf-vertical-scroll-bar-visibility ScrollView VerticalScrollBarVisibilityProperty -xf-min-track-color Slider MinimumTrackColorProperty -xf-max-track-color Slider MaximumTrackColorProperty -xf-thumb-color Slider ThumbColorProperty -xf-spacing StackLayout SpacingProperty -xf-orientation StackLayout OrientationProperty -xf-visual VisualElement VisualProperty -xf-vertical-text-alignment Label VerticalTextAlignmentProperty -xf-thumb-color Switch ThumbColorProperty Shell Specific Properties \u00b6 Property Applies To Value Type / Info -xf-flyout-background Shell FlyoutBackgroundColorProperty -xf-shell-background Element BackgroundColorProperty, PropertyOwnerType = Shell -xf-shell-disabled Element DisabledColorProperty, PropertyOwnerType = Shell -xf-shell-foreground Element ForegroundColorProperty, PropertyOwnerType = Shell -xf-shell-tabbar-background Element TabBarBackgroundColorProperty, PropertyOwnerType = Shell -xf-shell-tabbar-disabled Element TabBarDisabledColorProperty, PropertyOwnerType = Shell -xf-shell-tabbar-foreground Element TabBarForegroundColorProperty, PropertyOwnerType = Shell -xf-shell-tabbar-title Element TabBarTitleColorProperty, PropertyOwnerType = Shell -xf-shell-tabbar-unselected Element TabBarUnselectedColorProperty, PropertyOwnerType = Shell -xf-shell-title Element TitleColorProperty, PropertyOwnerType = Shell -xf-shell-unselected Element UnselectedColorProperty, PropertyOwnerType = Shell","title":"Supported Properties"},{"location":"scss-to-css/properties/#flexlayout","text":"Property Applies To Value Type / Info align-content FlexLayout AlignContentProperty align-items FlexLayout AlignItemsProperty align-self VisualElement AlignSelfProperty, PropertyOwnerType = FlexLayout flex-direction FlexLayout DirectionProperty flex-basis VisualElement BasisProperty, PropertyOwnerType = FlexLayout flex-grow VisualElement GrowProperty, PropertyOwnerType = FlexLayout flex-shrink VisualElement ShrinkProperty, PropertyOwnerType = FlexLayout flex-wrap VisualElement WrapProperty, PropertyOwnerType = FlexLayout justify-content FlexLayout JustifyContentProperty order VisualElement OrderProperty, PropertyOwnerType = FlexLayout position FlexLayout PositionProperty","title":"FlexLayout"},{"location":"scss-to-css/properties/#xamarinforms-specific-properties","text":"Property Applies To Value Type / Info -xf-placeholder IPlaceholderElement PlaceholderProperty -xf-placeholder-color IPlaceholderElement PlaceholderColorProperty -xf-max-length InputView MaxLengthProperty -xf-bar-background-color IBarElement BarBackgroundColorProperty -xf-bar-text-color IBarElement BarTextColorProperty -xf-orientation ScrollView OrientationProperty -xf-horizontal-scroll-bar-visibility ScrollView HorizontalScrollBarVisibilityProperty -xf-vertical-scroll-bar-visibility ScrollView VerticalScrollBarVisibilityProperty -xf-min-track-color Slider MinimumTrackColorProperty -xf-max-track-color Slider MaximumTrackColorProperty -xf-thumb-color Slider ThumbColorProperty -xf-spacing StackLayout SpacingProperty -xf-orientation StackLayout OrientationProperty -xf-visual VisualElement VisualProperty -xf-vertical-text-alignment Label VerticalTextAlignmentProperty -xf-thumb-color Switch ThumbColorProperty","title":"Xamarin.Forms Specific Properties"},{"location":"scss-to-css/properties/#shell-specific-properties","text":"Property Applies To Value Type / Info -xf-flyout-background Shell FlyoutBackgroundColorProperty -xf-shell-background Element BackgroundColorProperty, PropertyOwnerType = Shell -xf-shell-disabled Element DisabledColorProperty, PropertyOwnerType = Shell -xf-shell-foreground Element ForegroundColorProperty, PropertyOwnerType = Shell -xf-shell-tabbar-background Element TabBarBackgroundColorProperty, PropertyOwnerType = Shell -xf-shell-tabbar-disabled Element TabBarDisabledColorProperty, PropertyOwnerType = Shell -xf-shell-tabbar-foreground Element TabBarForegroundColorProperty, PropertyOwnerType = Shell -xf-shell-tabbar-title Element TabBarTitleColorProperty, PropertyOwnerType = Shell -xf-shell-tabbar-unselected Element TabBarUnselectedColorProperty, PropertyOwnerType = Shell -xf-shell-title Element TitleColorProperty, PropertyOwnerType = Shell -xf-shell-unselected Element UnselectedColorProperty, PropertyOwnerType = Shell","title":"Shell Specific Properties"}]}